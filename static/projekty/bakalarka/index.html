<?xml version="1.0" encoding="windows-1250"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=windows-1250"/>
	<meta name="Author" content="Ondra ika; ondra at dynawest.cz"/>
	<meta name="Keywords" content="JavaScript, EcmaScript, LiveScript, JScript, tenkı klient, klientská aplikace, klietské aplikace, dekompozice, Miner VGA, Miner JS, Ondøej ika, bakaláøská práce, diplomová práce, bakaláøka, diplomka"/>
	<meta name="Description" content="Textová èást bakaláøské práce o technologii JavaScript a jejím vyuití pro tvorbu klientskıch aplikací"/>
	<link rel="stylesheet" type="text/css" href="dw_styles.css"/>
	<link rel="stylesheet" type="text/css" href="styl.css"/>
	<script type="text/javascript"  charset="windows-1250" src="typografie.js"></script>
	<script type="text/javascript">
function OnLoad(){
	// Typografická pravidla 
	window.defaultStatus = "Probíhá aplikace typografickıch pravidel...";
	document.getElementById("splashscreen").style.visibility = "visible";	
	window.setTimeout('ZpozdenaAplikaceTypografie();', 1000);
}
function ZpozdenaAplikaceTypografie(){
	var oTypografie = new cTypografie();
	AplikujTypografiiNaStrom(document, oTypografie);
	window.defaultStatus = "";
	document.getElementById("splashscreen_zprava").innerHTML = "Aplikace typografickıch pravidel byla dokonèena. Pøeji pøíjemné ètení.";
	window.setTimeout('document.getElementById("splashscreen").style.display = "none";', 6000);
}
window.onload = OnLoad;
	</script>

<!-- Ondøej ika: Tvorba aplikací na stranì klienta s pouitím technologie JavaScript (diplomová práce) -->
<title> Ondøej ika: JavaScript a klientské aplikace (diplomová práce)</title>
</head>

<body>
<div id="content">
	<div id="predsadka">
		<p class="ju">Jihoèeská univerzita</p>
		<p class="pf">Pedagogická fakulta</p>
		<p class="oz">Ondøej ika</p>
		<!-- <p class="av">a vedoucí bakaláøské práce</p>
		<p class="jj">Ing. Jan Jára, Ph.D.</p> -->
		<p class="dp">Bakaláøská práce</p>
		<p class="nt">na téma</p>
		<h1>Tvorba aplikací na&nbsp;stranì klienta<br />s&nbsp;pouitím technologie JavaScript</h1>
		<p class="v">verze 1.2.4</p>
		<p class="av">Vedoucí bakaláøské práce:</p>
		<p class="jj">Ing. Jan Jára, Ph.D.</p>
	</div>
	
	<hr class="pagebreak" />
	
	<!-- Zadani -->
	<div id="zadani">
		<h2>Zadání</h2>
<div class="citace zadani">
	<h3>Tvorba aplikací na stranì klienta s pouitím technologie JavaScript</h3>
	<p>Technologie JavaScript bıvá mnohdy podceòována  z hlediska vyjadøovací síly jazyka,
	pouitelnosti pøi tvorbì aplikace a také svojí zdánlivou nemoností pracovat s daty.
	Pokuste se dokázat, e lze i jejím vıhradním pouitím vytvoøit smysluplné aplikace
	nevyadující podporu skriptování na stranì serveru.</p>
	
	<ul> <li>popište monosti této technologie
	</li><li>definujte oblast pouití této technologie pro tvorbu aplikací
	</li><li>popište monosti dekompozice problematiky s ohledem na dìlbu práce pro více programátorù
	</li><li>vytvoøte aplikaci, na které pøedvedete:
		<ul> <li>opodstatnìnost tvorby aplikací touto technologií
		</li><li>dekompozici problematiky
		</li></ul>
	</li></ul>
	
	<p>Nìkterá doporuèená literatura:</p>
	<ul class="literatura">
		<li>David Flanagan: JavaScript - kompletní prùvodce, 2. aktualizované vydání, Computer Press 2002, O'Reilly, ISBN 80-7226-626-8.</li>
		<li>Scott Isaacs: Dynamické HTML, Computer Press 1997, Microsoft Press 1997, ISBN 80-7226-083-9.</li>
		<li>Lee Purcell, Mary Jane Mara: JavaScript - tvorba dokonalıch WWW stránek - podrobnı prùvodce zaèínajícího uivatele (The ABCs of JavaScript), Grada Publishing 1998, SYBEX Inc. 1997, ISBN 80-7169-531-9.</li>
	</ul>
</div>
	</div>

	<!-- P'stuff -->
	<div id="prohlaseni">
		<h6>Prohlášení</h6>
		<p>Prohlašuji, e jsem tuto bakaláøskou práci vypracoval samostatnì
		a&nbsp;e&nbsp;jsem veškerou pouitou literaturu uvedl v&nbsp;seznamu pouité literatury.</p>
	</div>
	
	<div id="podekovani">
		<h6>Podìkování</h6>
		<p>Dìkuji vedoucímu bakaláøské práce, doktoru Ing. Janu Járovi, za&nbsp;ochotnou spolupráci pøi její tvorbì.
		</p><p>Dìkuji Harrelovi W. Stillesovi za podporu pøi rané fázi vıvoje hry Miner&nbsp;JS
		a&nbsp;pøedevším za&nbsp;svolení k&nbsp;uití jeho nápadù a&nbsp;grafiky z&nbsp;pùvodní verze.
		</p><p>Podìkování patøí také mım rodièùm, kteøí se ujali role korektorù,
		<!-- aèkoliv moc netušili, o&nbsp;èem e&nbsp;to&nbsp;ètou, -->
		a&nbsp;všem dalším lidem, kteøí&nbsp;mi pomáhali pøi opravách textu a&nbsp;testování hry.
		</p><p>A&nbsp;nakonec dìkuji i&nbsp;všem vıvojáøùm, na&nbsp;jejich mnohaleté práci nyní já mohu stavìt.
		</p>
	</div>
	

	<!-- Anotace -->
	<div id="anotace">
		<!-- Anotace -->

<div lang="cs-CZ">
	<h2>Anotace</h2>
	<p>Práce pøedstavuje technologii JavaScript jako plnohodnotnı programovací jazyk
	a dokazuje, e je moné ho pouít nejen pro skriptování v dokumentech HTML, co je jeho nejznámìjší vyuití,
	ale i pøi programování klientskıch i serverovıch aplikací a také jako skriptovacího jazyka vyšší úrovnì
	pro ovládání komplexních desktopovıch aplikací. Tyto monosti jsou pøedvedeny na reálnıch pøíkladech.
	Dále se zabıvá monostmi JavaScriptu pøi dekompozici podle principù objektovì orientovaného programování,
	a pojednává o nepøíliš známıch monostech vyuití JavaScriptu v prohlíeèích.
	Nakonec je popsána realizace praktické èásti.
	
	</p><p>Praktickou èást tvoøí aplikace Miner JS, logicko-ekonomická strategická hra, vytvoøená vıhradnì s pouitím
	technologií nabízenıch moderními prohlíeèi pro HTML dokumenty.
	</p>	
</div>

<div lang="en-US">
	<h2 class="no-page-break">Abstract</h2>
	<p>This bachelors thesis introduces the JavaScript technology as a fully usable programming language
	and proves its capability to be used not only for scripting in HTML documents, what is the commonly known
	domain of its use, but also for programming both client-side and server-side applications
	as well as a high-level scripting language for controlling complex desktop applications.
	These capabilities are demonstrated on real-world examples.
	Furthermore it deals with the possibilities of using JavaScript for decomposition by the means of
	object-oriented programming, and exposes not well-known ways to utilize JavaScript in web browsers.
	Finally, a realization of the practical part is described.

	</p><p>Practical part consist of a Miner JS application, a logical-economic strategy game,
	 entirely created using only technologies provided by modern web browsers for HTML documents.
	</p>
</div>




	</div>
	
	
		
	<!-- Osnova neboli obsah neboli TOC -->
	<div id="osnova">
		<h2>Obsah</h2>
		<div>
		
<ul class="" id="menu_predmluva">
	<li><a href="#k-a-1-1">Pøedmluva</a></li>
</ul>

<ul class="pismena_velka">
<li><a href="#k-a">Teoretická èást</a>
	<ul class="cisla">
	<li><a href="#k-a-1">Úvod do jazyka JavaScript</a>
		<ul class="cisla">
	  <li><a href="#k-a-1-2">Seznámení s JavaScriptem</a>
	    <ul class="pismena_mala">
			<li>Co JavaScript je</li>
	    <li>Co JavaScript není</li>
	    <li>Historickı vıvoj JavaScriptu
			</li>
			</ul>
		</li>
	  <li><a href="#k-a-1-3">Monosti uplatnìní JavaScriptu</a>
			<ul class="pismena_mala">
			<li><a href="#k-a-1-3-prohlizece">Pouití JavaScriptu jako vyššího jazyka pro ovládání èásti aplikace - prohlíeèe</a></li>
	  	<li><a href="#k-a-1-3-uzivatelske">Uivatelské skripty</a>
				<ul> <li>Microsoft Office
        </li><li>Allaire HomeSite
        </li><li>Macromedia Flash
        </li><li>Adobe Photoshop
        </li><li>Jasc Paint Shop Pro
        </li><li>Microsoft Windows Scripting Host
        </li></ul>
			</li>
	    <li><a href="#k-a-1-3-xul">Tvorba aplikací na základì frameworku pouívajícího JavaScript</a></li>
			</ul>
		</li>
		<li><a href="#k-a-1-4">Monosti JavaScriptu pøi dekompozici</a> - vyuití plnì objektového konceptu Javy
			<ul> <li><a href="#k-a-1-4-promenne_objektu">Èlenské promìnné objektu</a>
			</li><li><a href="#k-a-1-4-promenne_tridy">Promìnné tøídy</a>
			</li><li><a href="#k-a-1-4-konstanty">Konstanty tøídy</a>
			</li><li><a href="#k-a-1-4-rozklad_do_trid">Rozklad do tøíd</a>
      </li><li><a href="#k-a-1-4-vztah_ma">Dekompozice vztahu "má" - vnoøené objekty</a>
      </li><li><a href="#k-a-1-4-vztah_je">Dekompozice vztahu "je" - specializace tøídy (dìdiènost)</a>
      </li><li><a href="#k-a-1-4-rozhrani">Rozhraní (interface)</a>
			</li><li><a href="#k-a-1-4-baliky"  >Balíky</a>
      </li></ul>
		</li>
		<li><a href="#k-a-1-5">Monosti dekompozice s ohledem na kooperativní programování</a>
			<ul> <li><a href="#k-a-1-5-pojmy">Pojmy</a>
			</li><li><a href="#k-a-1-5-hranice">Hranice pùsobnosti</a>
			</li><li><a href="#k-a-1-5-komunikace">Komunikace</a>
			</li><li><a href="#k-a-1-5-komunikace_js">Komunikace pøi pouití JavaScriptu</a>
      </li></ul>
		</li>
		</ul>
	</li>
	<li><a href="#k-a-2">Struènı popis jádra jazyka JavaScript</a>
		<ul class="cisla">
		<li><a href="#k-a-2-1">Syntaxe</a> <!-- [ lexikální struktura, literály, vırazy, operátory, pøíkazy ] --></li>
		<li><a href="#k-a-2-1b">Konstrukce</a></li>
	  <li><a href="#k-a-2-2">Datové typy, promìnné</a><!--  [, konverze, pøedávání hodnotou a odkazem ] --></li>
	  <li><a href="#k-a-2-3">Funkce</a> <!-- [ definice, obor platnosti promìnnıch, datová reprezentace funkce ] --></li>
	  <li><a href="#k-a-2-4">Tøídy a objekty</a>
	  <!-- [ konstruktory, metody, instanciace, definice tøíd, prototypy a dìdiènost, uvolòování pamìti ] --></li>
	  <li><a href="#k-a-2-5">Regulární vırazy</a></li>
	  <li><a href="#k-a-2-6">Vestavìné objekty a metody</a>
	  <!-- [ Date, RegExp, Array, Error, obálky promìnnıch, globální funkce ] --></li>
		</ul>
	</li>
	<li><a href="#k-a-3">JavaScript ve webovıch prohlíeèích</a>
		<ul class="cisla">
		<li><a href="#k-a-3-1">Objekt <code>window</code></a></li>
		<li><a href="#k-a-3-2">Objekt <code>window.document</code></a></li>
		<li><a href="#k-a-3-6">Provázanost JavaScriptu s DOM</a>
			<!-- <ul class="pismena_mala">
				<li>(Ne)Kompatibilita MSIE</li>
				<li>Kompatibilita Mozilly</li>
			</ul> -->
		</li>
		<li><a href="#k-a-3-3">Provázanost JavaScriptu s HTML</a></li>
		<li><a href="#k-a-3-4">Provázanost JavaScriptu s CSS</a></li>
		<li><a href="#k-a-3-5">Provázanost JavaScriptu s Cookies</a></li>
		<li><a href="#k-a-3-7">Provázanost JavaScriptu s Javou</a></li>
		<li><a href="#k-a-3-8">Provázanost JavaScriptu s Flashem</a></li>
		<li><a href="#k-a-3-9">Provázanost JavaScriptu s SVG</a></li>
		<li><a href="#k-a-3-10">Bezpeènost</a></li>
		</ul>
	</li>	
	</ul>
	
</li>

<li style="margin-top: 1em;"><a href="#k-b">Praktická èást</a>
	<ul class="cisla">
  <li><a href="#k-b-1">Miner JS</a>
		<ul class="cisla">
		<li><a href="#k-b-1-1">Historie vıvoje hry</a></li>
		<li><a href="#k-b-1-2">Koncept hry</a></li>
		<li><a href="#k-b-1-3">Zvolené prostøedky pro zobrazení</a></li>
		<li><a href="#k-b-1-4">Dekompozice</a></li>
		<!-- <li><a href="#k-b-1-5">Realizace jednotlivıch èástí</a></li> -->
		<!-- <li><a href="#k-b-1-6">Testování</a></li> -->
		<!-- <li><a href="#k-b-1-7">[Stanovení ceny a prodej :)   ]</a></li> -->
		<li><a href="#k-b-1-8">Další monosti</a></li>
		</ul></li>
  <!-- <li><a href="#k-b-2">FlexiNET</a></li> -->
  <!-- <li><a href="#k-b-3">Mozilla Calendar</a></li> -->
  <!-- <li class="internal">[ II a III by byl rozbor aplikací. U FlexiNetu si nejsem jistı, jestli ho budu moci pouít. ]</li> -->
	</ul>
</li>
<li><a href="#k-z">Závìr</a></li>
<li><a href="#k-c">Zdroje</a></li>
<li><a href="#k-d">Seznam pøíloh</a></li>
</ul>

		</div>
	</div>
	<!-- #osnova - KONEC -->
	
	
	<hr />
	
	<div id="text">
	<div>
		<a name="k-a-1-1"></a>
		<h2>Pøedmluva</h2>
		<div><!-- Uvod / predmluva -->

<h5>Cíle práce</h5>
<p>Kdy se øekne JavaScript, mnozí lidé si vybaví úryvky kódu, kterımi dosahují 
na WWW stánkách efektù typu "digitální hodiny", zmìny obrázkù pøi pøejezdu myší a podobnì.
Èasto si pak udìlají o JavaScriptu úsudek, e je to primitivní jazyk, jeho monosti jsou
takovım pouitím vyèerpány
(<a target="_blank" href="http://www.crockford.com/javascript/javascript.html"
>JavaScript: The World's Most Misunderstood Programming Language</a>).

</p><p>JavaScript (dále obèas JS) je však sofistikovanı promyšlenı jazyk s pomìrnì unikátními vlastnostmi,
které jej èiní velmi vhodnım pro pouití jako skriptovací nástroj v nejrùznìjších prostøedích.
Díky zdaøilému návrhu je s ním moné jak napsat krátkı a
<abbr title="nestrukturovanı kód, sekvence pøíkazù bez èlenìní do funkcí èi metod">plochı</abbr>,
avšak ve vısledku velmi efektivní kód, tak vytvoøit rozsáhlou sloitou aplikaci zaloenou na objektovém modelu.
První pøípad je èastìjší - jsou to právì ty úryvky kódu zmínìné v pøedchozím odstavci.
Druhı pøípad mùete mít pøímo pøed oèima a nebudete o tom vìdìt: Víte, e prohlíeè Firefox
je vlastnì jen sada komponent spojenıch JavaScriptem?

</p><p>Tato bakaláøská práce si klade za cíl pøedstavit JavaScript
jako  dynamickı objektovì orientovanı obecnì pouitelnı multiplatformní sympatickı programovací jazyk.
Nesnaí se o vıuku JavaScriptu ani není referenèní pøíruèkou. Podle toho jsem také vybíral
témata a oblasti, kterımi se práce zabıvá. Nìkteré pasáe se tıkají vìcí souvisejících
s JS jen nepøímo, ale bylo je vhodné zaøadit. Naopak nìkteré aspekty JS ani nejsou zmínìny.

</p>

<h5>Nároky na ètenáøe</h5>
<p>Pøedpoklady pro porozumìní na stranì ètenáøe jsou:
<ul> <li>Znalost principù programování v <abbr title="jazyky vykonávané sekvenènì vyjadøující se 
	posloupností elementárních pøíkazù a konstrukcí jako podmínky (if-then-else), cykly (for, while)"
	>procedurálních jazycích</abbr> (napø. C, Pascal, Java, Python, PHP, Perl, TcL...)
</li><li>Znalost filosofie objektovì orientovaného programování (OOP)
</li><li>Znalost principu fungování aplikací øízenıch událostmi (event-driven applications)
</li><li>Znalost syntaxe jazyka JavaScript
(<a target="_blank" href="http://www.ecma-international.org/publications/files/ecma-st/ECMA-262.pdf"
>ECMAScript Language Specification - 3rd edition</a>), nebo aspoò èásteèná znalost syntaxe jazyka Java, C++, PHP nebo podobného
<!-- </li><li>Znalost jazyka XML (<a target="_blank" href="http://www.w3.org/TR/2000/REC-xml-20001006">Extensible Markup Language (XML) 1.0 (Second Edition)</a>) -->
</li><li>Znalost vıznamù elementù jazyka (X)HTML (<a target="_blank" href="http://www.w3.org/TR/xhtml1/"
>XHTML™ 1.0 The Extensible HyperText Markup Language (Second Edition)</a>)
</li><li>Znalost principu fungování WWW stránek a protokolu HTTP a z nich vyplıvajících omezení
</li><li>Znalost Document Object Model (DOM) implementovaného jako souèást klientského JavaScriptu
</li><li>Silnì doporuèuji nainstalovat <a target="_blank" href="http://firefox.czilla.cz/">prohlíeè Firefox</a>
	a nadšenci mohou instalovat i <a target="_blank" href="https://addons.update.mozilla.org/extensions/moreinfo.php?application=firefox&amp;version=1.0&amp;os=Windows&amp;category=Developer%20Tools&amp;numpg=10&amp;id=216"
	>Venkman extension</a> (JavaScript debugger), pøípadnì další <a target="_blank" href="https://addons.update.mozilla.org/extensions/showlist.php?application=firefox&amp;version=1.0&amp;os=Windows&amp;category=Developer%20Tools"
	>rozšíøení Firefoxu urèená pro vıvojáøe</a>
</li><li>Hravou povahu a trpìlivost pro vyzkoušení <a href="#k-b">praktické èásti</a> - hry <a href="http://ondra.zizka.cz/projekty/miner/">Miner JS</a>
</li></ul>

</p>

<h5 style="page-break-before: always;">XHTML jako formát textové èásti práce</h5>
<p>Jako formát této práce jsme zvolili XHTML. Pro tuto volbu existuje nìkolik pádnıch dùvodù:
</p>

<ul> <li>XHTML je otevøenı formát s veøejnou specifikací. Je tedy jednoduše pøenositelnı mezi programy i platformami.
</li><li>XHTML je také vhodnı jako vstupní formát pro pøevod do dalších formátù jako napø. PDF.
Obsahuje všechny podstatné metainformace o obsahu.
</li><li>Vizuální prezentace obsahu je velmi jednoduše upravitelná pomocí CSS.
Pouívání principu stylù ve WYSIWYG editorech jako napø. MS Word je neohrabané, zmatené a ve vısledku spíše kontraproduktivní.
</li><li>V XHTML lze jednodušeji pouívat køíové odkazy.
</li><li>XHTML spolu s CSS nabízí daleko vìtší monosti formátování obsahu.
</li><li>XHTML je formát pro web - práci je tedy mono vystavit na internetu.
</li><li>V XHTML dokumentu mùeme pøímo pøedvést pøedmìt práce - JavaScript.
</li><li>A v neposlední øadì se nepochybnì jedná o originální a novátorskou formu diplomové práce :-)
</li></ul>

<p>Pouití XHTML má ovšem i nevıhody, kterıch si všimnou pøedevším ti, kteøí ètou tištìnou verzi tohoto dokumentu.
Kombinace XHTML + CSS je momentálnì primárnì urèena pro zobrazování dokumentu na internetu.
Cituji úvod <a href="http://www.xml.com/pub/a/2002/03/20/xsl-fo.html">èlánku Kena Holmana</a>
 ze serveru <a href="http://www.xml.com/">www.xml.com</a>:
</p>
<div class="block quote">
	<p>We often take the printed form of information for granted,
	yet how many of us are satisfied with the print-screen functionality from a web browser?
	How many times have you printed a lengthy web document
	and found the paginated result to be as easily navigated as the electronic original?
	</p>
</div>
<p>Pouití XHTML pro formátování tištìného dokumentu je zatím neobvyklé, a pokud u se realizuje,
pøed tiskem se dokument pøevede pomocí technologie <a href="http://www.w3schools.com/xsl/">XSLT</a> na nìjakı vhodnìjší formát,
napø. PDF, nebo v poslední dobì <a href="http://www.w3schools.com/xslfo/default.asp">XSL-FO</a>,
se kterım u pracují nìkteré programy pro sazbu textù (a o nìm je vıše citovanı èlánek).

</p><p>Jak naznaèuje citace, schopnosti prohlíeèù formátovat webové stránky pro tisk jsou pomìrnì omezené.
Oproti textovım editorùm (zatím) nedisponují zejména nejrùznìjšími typografickımi technikami jako je
spojování pøedloek s následujícím slovem, rozdìlování slov, hlídání tzv. sirotkù a vdov apod.
Dále si nedovedou dost dobøe poradit pøi dìlení obsahu mezi stránky, a tak èasto rozdìlí i malı obrázek
mezi dvì stránky.
<!-- Update - v. 1.1.0 -->
Svazování pøedloek s následujícím slovem je v této práci vyøešeno pomocí JavaScriptu.
Problémy související se stránkováním však s jeho pomocí vyøešit nejde.


</p><p>Dalším problémem je neúplná podpora nebo nekorektní implementace CSS.
Prohlíeèe napøíklad nedokáou rozlišit liché a sudé stránky a odlišnì upravit jejich okraje,
aèkoliv na tuto funkci je v CSS pamatováno pravidlem <code class="css">@page</code>.
Špatnì funguje automatické èíslování elementù, take kapitoly je nutno èíslovat ruènì.
Také vıše zmínìné hlídání sirotkù a vdov je v CSS øešeno - vlastnostmi <code>orphans</code> a <code>widows</code>.
Vytvoøení záhlaví a zápatí se provádí pomocí vlastnosti <code>position: fixed</code>, tu však
neimplementuje Internet Explorer.

</p><p>A nakonec vadí i samotná specifikace CSS, která ve verzi 2.1 vùbec neøeší
napø. èíslování stránek, poznámky pod èarou a podobnì.

</p>


<h5 style="page-break-before: always;">Terminologie</h5>
<p>Terminologie a odborné termíny nejsou v práci pouívány striktnì.
Napøíklad v JavaScriptu se sice funkce nazıvá funkce, a zároveò veškeré
funkce jsou metodami nìjakého objektu. V práci se vyskytují oba termíny
- "funkce" zdùrazòuje roli funkce jako objektu JavaScriptu typu Function,
kdeto "metoda" zdùrazòuje, e jde o funkci manipulující s objektem.

</p>

<h5>Rozlišení typù zdrojovıch kódù</h5>
<p>V práci se vyskytují ukázky nìkolika programovacích a popisnıch jazykù a jinıch formátù.
Odlišují se rùznou barvou pozadí.
Pøi tisku práce proto doporuèujeme zapnout v prohlíeèi tisk obrázkù a barev na pozadí.
Kód JavaScriptu má šedé pozadí, tmavì šedı rámeèek
a vpravo nahoøe je tato ikonka: <img src="img/icon_js_small.gif" alt="" width="16" height="16" style="margin-top: 3px;" />

</p>


<!-- http://www.hesketh.com/publications/javascript_history.html -->
<!-- <p>Pùvodnì byl vyvinut firmou Netscape jako jazyk pro skripty v prohlíeèi Navigator.

Pozdìji podobnı jazyk implementoval v prohlíeèi Internet Explorer i Microsoft, a jak je jeho
tradicí, pokusil se jazyk nìjak vylepšit.
Èasem se ve svıch prohlíeèích o podporu JavaScriptu a jeho MS derivátu více èi ménì úspìšnì pokusili
i&nbsp;vırobci dalších prohlíeèù; ne kadı však správnì odhadl, jak JavaScript funguje vnitønì.
Vzniklo tak nìkolik vzájemnì nekompatibilních implementací JS a vıvojáøùm WWW stránek vznikly komplikace.
Kvùli
</p> --></div>
	</div>
	
	<!-- A. Teoretická èást -->
	<div class="cast_teorie">
		<a name="k-a"></a>
		<h2>A. Teoretická èást</h2>
		<div>
			<a name="k-a-1"></a>
			<h3>A.1. Úvod do jazyka JavaScript</h3>
			<div>
				<a name="k-a-1-2"></a>
				<h4>A.1.1. Seznámení s JavaScriptem</h4>
				<div><!-- Úvod / Seznámení s JavaScriptem -->


<!-- Co JavaScript je  -->
<h5>Co JavaScript je</h5>
<div>
    <p><strong>JavaScript je procedurální programovací jazyk.</strong>
Jeho syntaktická podoba bude blízká programátorùm
v C a odvozenıch jazycích: syntaxe JavaScriptu byla odvozena od syntaxe Javy byla odvozena 
od syntaxe C++ byla odvozena od syntaxe C. Zde je krátká ukázka kódu:

		<!-- Pøíklad 1 -->
<pre><code class="js" id="priklad_1" title="Pøíklad 1 - ukázka kódu JavaScriptu"
><span class="k">function</span> Pozdrav<span class="o">(){</span>
  <span class="f">alert</span><span class="o">(</span><span class="s">"Ahoj lidi!"</span><span class="o">);</span>
<span class="o">}</span>

Pozdrav<span class="o">();</span></code></pre>
		<!--  -->
	
Tento kód nejprve definuje funkci se jménem Pozdrav, která zavolá funkci <code class="jsl">alert()</code>,
a následnì ji zavolá (provede). Vidíte tedy, e podoba s C èi Javou je velká.

<!-- objektovì orientovanı -->
</p><p><strong>JavaScript je objektovì orientovanı jazyk.</strong>
V pøedchozím pøíkladu jsme definovali funkci. Tak se to dá øíci zjednodušenì. V rozporu s klíèovım slovem function,
které je dáno historickımi dùvody, ve skuteènosti v JavaScriptu funkce z pohledu OOP neexistují, existují pouze metody,
a vše kromì skalárních promìnnıch je objekt.
Na metodu je ovšem tøeba tøída, které by patøila. Kam tedy patøí funkce <code class="jsl">Pozdrav()</code> ?
<em>Definicí funkce bez pøiøazení nìjakému objektu ji automaticky pøiøazujete aktuálnímu objektu nejvyšší úrovnì.</em>
V tomto vıroku se však skrıvají hned tøi chytáky:

</p><p>Nejprve <em>pøiøazení metody objektu</em>. V jazycích s pevnou strukturou tøíd jako jsou C++ nebo Java
se metody definují pro tøídu, a kadá instance má právì tuto nemìnnou sadu metod. Ne tak v JS. Ten pouívá pro
realizaci OOP tzv. prototypy, co jsou jakési vzorové objekty, z nich vznikají instance zvláštním odvozením od nich.
Více dále v dokumentu.

</p><p>Dalším chytákem je <em>objekt nejvyšší úrovnì</em>. Je to speciální objekt, kterı má nìkolik úloh.
Mimo jiné implementuje funkce jako <code class="jsl">eval()</code>, <code class="jsl">isNan()</code> nebo <code class="jsl">parseInt()</code>.
Jsou v nìm pøímo èi nepøímo obsaeny veškeré další objekty daného kontextu, pøièem kontext je další téma na vysvìtlení.

</p><p>Poslední chyták je <em>aktuální objekt nejvyšší úrovnì</em>. Copak jich mùe bıt více? Ano, mùe existovat
libovolnı poèet objektù nejvyšší úrovnì, a to nezávisle na sobì, ale zároveò o sobì mohou vìdìt. Nejlepším pøíkladem
jsou objekty nejvyšší úrovnì v prohlíeèích - objekty <code class="jsl">window</code>. Kadé okno èi rám má vlastní
objekt window, kterı obsahuje promìnné a metody definované kódem v naètené stránce. Pokud jsou v nìkteré stránce
vytvoøeny rámy elementem <code class="htmli">&lt;frameset&gt;</code>, navzájem se na sebe odkazují pøes vlastnost
<code class="jsl">window.top</code>, která odkazuje na objekt window okna obsahující tyto rámy. Ten má dále vlastnost
<code class="jsl">frames</code>, co je kolekce objektù window jednotlivıch rámu. Nyní pokud nìjakı rám definuje metodu
<code class="jsl">Pozdrav()</code>, ta se pøiøadí objektu window tohoto rámu, a nebude tak pøímo viditelná z jiného 
rámu a je tøeba ji volat nepøímo pøes <code class="jsl">window.top.frames[...].Pozdrav();</code>


</p><p><strong>JavaScript je multiplatformní.</strong> Jeliko je specifikován abstraktnì, záleí pouze na tom,
na jakıch všech platformách byl implementován. Teoreticky by mohl fungovat tøeba i v mobilních telefonech.

</p><p><strong>JavaScript je dynamickı.</strong> Jeliko se jedná o interpretovanı jazyk, mùe si dovolit náleité
vymoenosti jako metodu eval(), která vykoná kód vloenı jako øetìzec, dynamické typování, definice a zmìna tøíd za bìhu,
sebereflexe a další. Napø. pøiøazením nové metody prototypu tøídy String mùete zmìnit chování nejen všech objektù String
vytvoøenıch v budoucnu, ale i všech ji vytvoøenıch:
<pre><code class="js"
><span class="cml">// Pøiøazení nové metody pøeddefinovanému objektu</span>
<span class="f">String</span><span class="o">.</span>prototype<span class="o">.</span>Reverse <span class="o">=</span> <span class="k">function</span> <span class="o">(){</span>
  <span class="k">var</span> s <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
  <span class="k">for</span><span class="o">(</span>i <span class="o">=</span> this<span class="o">.</span>length<span class="o">;</span> i <span class="o">&gt;=</span> <span class="n">0</span><span class="o">;</span> i<span class="o">--){</span>
    s <span class="o">+=</span> <span class="k">this</span><span class="o">[</span>i<span class="o">];</span>
  <span class="o">}</span>
  <span class="k">return</span> s;
<span class="o">}</span></code></pre>
(Bohuel toto zatím funguje jen teoreticky, zatím všechny implementace úpravu nativních tøíd nepodporují.)

</p><p><strong>JavaScript je obecnì pouitelnı.</strong> Aèkoliv drtivá vìtšina lidí ho zná pouze z webovıch prohlíeèù,
skuteènost je taková, e JavaScript sám o sobì je pouitelnı k jakémukoliv úèelu, pro kterı staèí interpretovanı jazyk.
Èasto po nìm sahají vırobci sloitého softwaru, u kterého chtìjí uivatelùm nabídnout monost naprogramovat
rutinní postupy do skriptu zvaného <em>makro</em>.
Pøíkladem je tøeba implementace JavaScriptu firmou Allaire v&nbsp;editoru&nbsp;HomeSite, firmou Adobe v&nbsp;grafickém editoru Photoshop
nebo firmou Microsoft ve&nbsp;vıvojovém prostøedí Visual Studio, v&nbsp;aplikaci Windows Scripting Host, v&nbsp;technologii ASP
a&nbsp;v&nbsp;dalších produktech.

</p><p>O obecnosti JavaScriptu a nezávislosti na implementaci svìdèí fakt, e napøíklad v produktech firmy Microsoft
je obvykle mono pouít JavaScript místo jazyka VBscript, s dosaením (pøinejmenším) stejnıch vısledkù.
To je dáno tím, e tìmito jazyky jsou ovládány objekty <abbr title="Component Object Model">COM</abbr>,
a to prostøednictvím metod vystavenıch v jejich rozhraní (viz <a href="http://www.microsoft.com/com/">COM: Component Object Model Technologies</a>).
Kromì jádra jazyka se tedy pøíkazy sémanticky shodují.

</p><p>Spoleènost <a target="_blank" href="http://www.mozilla.org/">Mozilla.org</a> dala volnì k pouití vlastní implementaci
jádra JavaScriptu, kterou mùe kdokoliv pouít jako skriptovací jazyk pro svoji aplikaci. Tato implementace obsahuje
pouze to, co je povinné podle definice ECMAScript (Standard ECMA-262). Veškeré další vlastnosti u závisí na uivateli implementace.

</p>
</div>
<!-- Co JavaScript je - KONEC  -->



<!-- Co JavaScript není  -->
<h5>Co JavaScript není</h5>
<div>
    <p>Z pøedchozích odstavcù víceménì vyplıvá, co JavaScript není:
		<ul>
			<li>Není to jen jazyk pro programování www stránek.</li>
			<li>Není to zjednodušená verze Javy.</li>
			<li>Není to jazyk pro jen pro amatéry, nevhodnı pro profesionální programování.</li>
		</ul>
</p>
</div>
<!-- Co JavaScript není - KONEC  -->


<!-- Historickı vıvoj JavaScriptu  -->
<a name="k-a-1-2-hist"></a>
<h5>Historickı vıvoj JavaScriptu</h5>
<div>
    <h6>JavaScript v prohlíeèi Netscape Navigator</h6>
    <p>JavaScript byl vyvinut firmou Netscape (autorem návrhu Brendan Eich) pro skriptování v prohlíeèi WWW stránek Navigator 2.0.
Verze v nìm implementovaná se dnes oznaèuje jako JavaScript 1.0. Oproti návrhu obsahovala mnoho chyb - 
mnoho vìcí nešlo vùbec provést, mnoho se chovalo jinak, ne bylo urèeno v návrhu.
</p><p>V Navigatoru 3.0 byly v JavaScriptu 1.1 napraveny nejhorší chyby.
</p>
<img class="border" alt="Poslední novinka firmy Netscape - Navigator 3.0" src="img/banner_navigator30.gif" />
<p>V JavaScriptu 1.2, implementovaném v Navigatoru 4, byly odstranìny další chyby a pøidány nové prvky,
napøíklad pøíkaz <code class="jsl">switch</code> a regulární vırazy.
</p><p>S Navigatorem 4.5 pøišel JavaScript 1.3, kterı odpovídal standardu ECMAScript 1.
</p><p>JavaScript 1.4 byl implementován jen na serverovıch produktech Netscape.
</p><p>JavaScript 1.5 je implementací standardu ECMAScript 3 v Navigatoru 6 a opìt obsahuje nové prvky, zejména vıjimky.
</p>

    <h6>JavaScript v prohlíeèi Microsoft Internet Explorer</h6>
    <p>Firma Microsoft se po poèáteèním zavrení internetu jako neperspektivního vıstøelku akademikù vzbudila
a opøela se do vıvoje Internet Exploreru.
<!-- Jako obvykle mìla v plánu udìlat špatnou kopii všeho dobrého od konkurence, vytlaèit konkurenci z trhu
a pak zaèít divoké zlepšování. -->
Mìla v plánu pøevzít vìtšinovı podíl na trhu, a proto do prohlíeèe spìšnì zahrnula mnoho technologií, zejména JavaScript, CSS, DOM.
Tyto technologie se však na veøejné pùdì teprve formovaly na základì širokého konsenzu vıvojáøù prohlíeèù,
tvùrcù webù a dalších zainteresovanıch profesí, a proto nebyly pøipraveny k ostrému pouití.
To se však firmì Microsoft nehodilo, a tak vìtšinu z nich dotáhla svéráznım zpùsobem do stavu, kdy je pouívat šlo.
<!-- Pro skriptování v nìm vyvinula svoji obdobu JavaScriptu se jménem JScript. -->
To se vıraznì dotklo i JavaScriptu a objektového modelu dokumentu
a v prohlíeèi tak existují nesystémové konstrukce typu <code>document.all</code>,
velmi zvláštní zpùsob šíøení a zachytávání událostí a další odchylky od všeobecnì dohodnutého standardu.

</p><p>Na druhou stranu Internet Exploreru jistì nelze upøít jeho velmi vıznamnou historickou roli.
Zaprvé zpopularizoval právì ony technologie, by s mírnımi odchylkami, a velmi posunul vıvoj webu
od suchıch statickıch dokumentù smìrem k interaktivním inteligentním stránkám, které by se daly oznaèit za tenké klienty.
Zadruhé získáním dominantního podílu na "trhu" prohlíeèù dotlaèila firmu Netscape témìø ke krachu,
a ji nakonec koupila firma AOL. Zastaralı prohlíeè Navigator s nepatrnım podílem na trhu byl pro nového majitele
neatraktivní a neperspektivní, a zadarmo dal k dispozici jeho zdrojové kódy veøejnosti.
Byla zformována <a href="http://www.mozilla.org/">Nadace Mozilla</a>, která sdruila èást pùvodních programátorù
z Netscapu a dobrovolné vıvojáøe z celého svìta s cílem pokraèovat ve vıvoji prohlíeèe.
Po analıze stávajícího kódu dospìli k rozhodnutí prakticky kompletnì vše pøeprogramovat.
Postupnì ve skrytu a bez zájmu široké veøejnosti vytvoøili nìkolik vyspìlıch technologií -
renderovací jádro Gecko s korektním pojetím principù CSS,
aplikaèní kostru Mozilla Framework s technologií XUL, a další, které pozdìji spojili do celıch aplikací.
Dnes, po letech vıvoje, díky jejich úsilí existuje moderní prohlíeè Firefox, ctící standardy,
pomìrnì stabilní, bezpeènı, chovající se prakticky stejnì na všech platformách a rychle se vyvíjející dále.

</p><p>Toto by se asi bez prohlíeèe Internet Explorer nestalo.

</p><p>Nejprve pøišel&nbsp;MSIE 3.0 - tam se o JavaScripu moc nedá mluvit, ale JScript&nbsp;1.0 byl hrubou kopií JavaScriptu&nbsp;1.0.
JScript&nbsp;2.0 v pozdìjších verzích MSIE&nbsp;3.0 odstraòoval zásadní nekompatibility tak, 
aby v MSIE fungovaly základní skripty urèené pro Netscape Navigator.

</p><p>Opravdovım pøelomem pak byl Internet&nbsp;Explorer&nbsp;4.0. Ten byl jedním ze stìejních prvkù Microsoftu
na cestì k dominanci. Prohlíeè byl integrován do systému Windows 98, z èeho pozdìji vyplynuly
nesmyslné nìkolikaleté soudní spory, jejich vısledkem byl pøíkaz, e prohlíeè musí bıt moné ze systému odinstalovat.
JScript 3.0 v této verzi byl urèen zejména k rozpohybování Dynamického HTML (DHTML).
Byly pøidány zcela nové vlastnosti, prvky a postupy, napøíklad pseudo-kolekce <code class="jsl">all</code>,
dále monost prakticky libovolné práce se stromem dokumentu, ovládání CSS vlastností, a také podpora ActiveX objektù,
které více ne èemukoliv jinému poslouily šíøení virù.

</p><p>Dále byl ze strany Microsoftu JScript upravován tak, aby aspoò èásteènì odpovídal standardùm.
JScript&nbsp;5.0 v prohlíeèi IE&nbsp;5.0 èásteènì odpovídá standardu ECMAScript&nbsp;3.
JScript&nbsp;5.5 v prohlíeèi IE&nbsp;5.5 pak odpovídá standardu ECMAScript&nbsp;3 úplnì.
</p>

    <h6>Standard ECMAScript</h6>
    <p>Vıvoj JavaScriptu byl od poèátku velmi bouølivı. Od návrhu do uvolnìní veøejnosti neuplynula dlouhá doba
a JavaScript tak pøišel o uzavøenı cyklus analızy a testování, bìnı pro programovací jazyky. Navíc jeho implementaci, 
vylepšování a zmìny provádìlo nìkolik vırobcù najednou.	Je a pøekvapivé, jak ideovì èistı jazyk takto vznikl.
</p><p>Standardizace JavaScriptu se ujala organizace
<a href="http://www.ecma-international.org/">ECMA (European Computer Manufacturers Association)</a>.
Vydala nìkolik verzí standardu nazvaného
<a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">ECMAscript</a> s kódovım oznaèením ECMA-262 nebo také ISO/IEC 16262. Poslední, tøetí vydání je z prosince 1999.
Další se plánuje na konec roku 2005.
Vıvoj tohoto standardu zprvu vedly spoleènosti Netscape a Microsoft. Vıslednı standard je podmnoinou
dovedností interpreterù jazyka JavaScript od obou spoleèností, avšak ménì ne jejich prùnikem.
Je však tøeba podotknout, e standard se tıká pouze jádra JavaScriptu, nikoliv klientského API prohlíeèù.
</p><p>Tento standard bıvá obèas <a href="http://www.crockford.com/javascript/javascript.html">kritizován</a>.
Je mu vytıkána nesrozumitelnost a návrhové chyby.
</p><p>ECMA vydává i jiné standardy tıkající se JavaScriptu - napøíklad
<a href="http://www.ecma-international.org/publications/standards/Ecma-357.htm">ECMA-357 - ECMAScript for XML (E4X)</a>.
</p>

<p>Další zajímavé informace o historii JavaScriptu najdete v èlánku
<a href="http://hesketh.com/publications/javascript_history.html"> JavaScript: How Did We Get Here</a>.
</p>
</div>
<!-- Historickı vıvoj JavaScriptu - KONEC  -->


</div>
			</div>
			<div>
				<a name="k-a-1-3"></a>
				<h4>A.1.2. Monosti uplatnìní JavaScriptu</h4>
				<div><!-- Úvod / Monosti uplatnéní JavaScriptu -->


<p>Pro svoji univerzálnost mùe bıt JavaScript zvolen prakticky kdekoliv,
kde je tøeba nìjakı principiálnì jednoduchı, avšak mocnı skriptovací jazyk.
Napø. tam, kde je tøeba zjednodušit programování a sloitost vrstvy, na které
pracuje, zredukovat do sady objektù a jejich vlastností a metod.
Nebo tam, kde je tøeba umonit uivateli vytvoøit automatizované akce - makra.
Ta se mohou vygenerovat na základì uivatelem provádìnıch operací a uloit
jednoduše jako textovı soubor, kterı se mùe podle potøeby pozmìnit.
</p>


<a name="k-a-1-3-prohlizece"></a>
<h5>Pouití JavaScriptu jako vyššího jazyka pro ovládání èásti aplikace - prohlíeèe</h5>
<p>Nejbìnìjší aktivní i pasivní pouití JavaScriptu je jednoznaènì ve webovıch prohlíeèích.
JavaScript rozšiøoval svou pùsobnost postupnì na vìtší a vìtší èást prohlíeèe,
a nastala situace, kdy prakticky celé renderovací jádro je prorostlé JavaScriptem skrz naskrz
a skoro neexistuje nic, co by se jím nedalo ovládat. Navíc èásteènì mùe ovládat i nìkteré funkce
prohlíeèe. Zkrátka je vidìt, e zde je hlavní doména JavaScriptu.
Rozsah pùsobnosti JavaScriptu v prohlíeèích je popsán v kapitole <a href="#k-a-3">JavaScript ve webovıch prohlíeèích</a>.

</p><p>Nedlouho pøed dokonèením této práce bylo na
<a href="http://mail.centrum.cz/">E-mailovém serveru Centrum.cz</a>
spuštìno nové uivatelské rozhraní. Jeho technické øešení je revoluèní
a vyslovuji jeho tvùrcùm svùj obdiv.
Vytvoøili toti neuvìøitelnì kvalitní simulaci grafického prostøedí
bìné desktopové aplikace s vìtšinou jejích vıhod jako pøetahování mezi slokami,
nìkolik oken s rùznımi zprávami a další prvky chování komfortních e-mailovıch klientù.
Aplikaci ještì korunovali vytvoøením vlastních formuláøovıch prvkù,
které tak ji nejsou omezeny monostmi vestavìnıch prvkù a mohou jakkoliv vypadat i fungovat.
A celé to bìí jak v Internet Exploreru, tak v prohlíeèích dodrujících standardy.

</p><p>Ovšem kde jsou monosti JavaScriptu zdánlivì vyèerpány
a&nbsp;kde jeho pùsobnost bìnì konèí,
tam v jedné vıjimeèné aplikaci teprve zaèíná.
V aplikacích Nadace Mozilla je klientské skriptování v HTML dokumentech jen špièkou ledovce.
Jsou toti celé naprogramované v JavaScriptu.
</p><p>Zpùsob, jakım tyto aplikace tìí z JavaScriptu maximum, si ji 
vyslouil nìkolik knih, desítky manuálù, stovky èlánkù a tisíce diskuzí.
I já tomuto fenoménu vìnuji <a href="#k-a-1-3-xul">zvláštní oddíl</a>.
</p>




<a name="k-a-1-3-uzivatelske"></a>
<h5>Uivatelské skripty - Office, HomeSite, Macromedia, Adobe Photoshop, Paint Shop Pro, Windows Scripting Host</h5>
<p>Jednou z nejefektivnìjších moností, jak dát programu obrovskou pøidanou hodnotu a zapojit zdatnìjší uivatele
do vylepšování softwaru, je umonit jim modifikovat chování programu a pøidat mu nové schopnosti.
Bìnou metodou k dosaení takového cíle je proskriptování programu.
Jednotlivım komponentám programu se urèí styèné body, které budou vystaveny skriptovacímu prostøedí,
a naprogramuje se jim pøíslušné rozhraní. V prostøedí skriptovacího jazyka se pak tyto body jeví jako
jednotlivé prostøedky, jejich prostøednictvím se komponenty ovládají a spojují do souèinnosti ve&nbsp;smysluplné celistvé akci.


</p><p>Takovıto obecnı popis mnoho neøíká. Pøeveïme si ji tedy do pøípadu, kdy chceme proskriptovat jednoduchı grafickı editor
pomocí JavaScriptu.
Analızou zjistíme, e je vhodné vytvoøit napøíklad objekt pro aplikaci a objekty pro jednotlivé otevøené obrázky.
V&nbsp;objektu aplikace bude vlastnost reflektující aktuální nástroj.
Také bude moná vhodné vytvoøit kolekci s prvky, které budou pøedstavovat jednotlivé nástroje k vıbìru.
Urèitì bychom mìli objektu obrázku vytvoøit metodu, která by na nìj aplikovala filtry.
Tímto zpùsobem postupnì navrhneme vhodnı objektovı model, kterı bude mono pouít k&nbsp;ovládání aplikace.

</p><p>Nyní musíme k jednotlivım objektùm, vlastnostem a metodám naprogramovat adekvátní reakci v samotné aplikaci.
Architektura aplikace vùbec nemusí reflektovat architekturu našeho návrhu. Staèí, kdy se to tak bude jevit
z pohledu skriptu. Pøedpokládejme, e&nbsp;ve&nbsp;skriptu je napøíklad pøíkaz
<code class="jsl">application.activeImage.applyFilter(<span class="k">new</span>&nbsp;GrayFilter(0.5))</code>.
Pøesuòme se nyní z&nbsp;JavaScriptu do kódu naší aplikace a popišme si, co se na základì onoho JavaScriptového pøíkazu dìje:

</p><p>Pro komunikaci naší aplikace s interpreterem JavaScriptu existuje rozhraní, které musí aplikace implementovat.
Toto rozhraní obsahuje funkce, které aplikaci øíkají, co má podle skriptu provádìt.

Nejprve interpreter JavaScriptu øekne naší aplikaci, e má vytvoøit objekt tøídy <code>GrayFilter</code>,
a konstruktoru byl pøedán urèitı parametr. Pro toto sdìlení existuje v rozhraní funkce, øeknìme
<code>createObjectFromClass(sNázevTøídy, aParametryKonstrukoru, pVracenıObjekt)</code>.
Ta je volána a jako parametr je jí pøedán øetìzec "GrayFilter", pole s objekty s informacemi o parametrech
a ukazatel na ukazatel, kam máme vrátit novì vytvoøenı objekt.
Na základì pøedanıch informací danı objekt vytvoøíme a vrátíme.
Interpreter JavaScriptu si ho pøevezme a uloí zatím kamsi do svıch útrob.

Dále interpreter najde ji existující datovou strukturu, která reprezentuje globální objekt <code>application</code>,
a "pøeète" z ní vlastnost <code>activeImage</code>. Ètení je provedeno jako volání funkce rozhraní, øeknìme
<code>getProperty(<i>sNázevVlastnosti</i>, pVracenıObjekt)</code>. Ta vrátí opìt datovou strukturu, tentokrát reprezentující
objekt <code>activeImage</code>. Nad touto strukturou je volána funkce tøeba
<code>callMethod(sJménoMetody, aParametry, pVracenıObjekt)</code>, kterou musíme naprogramovat tak,
aby provedla poadovanou akci. Funkci <code>callMethod()</code> je v poli aParametry pøedán jako jeden z jeho prvkù
také objekt <code>GrayFilter</code>, kterı jsme vytvoøili pøi volání <code>createObjectFromClass</code>.

</p><p>Tímto zpùsobem probíhá celé vykonávání kódu JavaScriptu.
Jednotlivé interpretery JavaScriptu se mohou lišit, a to nejen názvem funkcí rozhraní a a jejich parametrù,
ale i zásadnìji: Interpreter v naší ukázce je pøedstavitel tzv. pasivní implementace. Pasivnì ovšem implementujeme my:
Èekáme, co nám interpreter pošle za string (napøíklad pøi volání metody), a na základì toho teprve reagujeme.
Naproti tomu aktivní implementace je taková, kdy pøi inicializaci bìhového prostøedí musíme pøedat interpreteru 
veškeré objekty, které mají bıt v bìhovém prostøedí vystaveny, a v prùbìhu vykonávání skriptu
prùbìnì tyto objekty aktualizovat, aby odpovídaly souèasnému stavu. Interpreter takto ménì volá funkce komunikaèního rozhraní
a více ète právì z tìchto objektù.
</p>

<h6>Office</h6>
<p>Kanceláøskı balík Microsoft Office dává k dispozici mohutnou aparaturu k ovládání aplikací.
Jako primární jazyk byl v historii zvolen Visual Basic Script, je však moné pouít i JavaScript.
Následující ukázka provede zámìnu øetìzce "&amp;" za øetìzec "&amp;amp;":
</p>
<pre><code class="js"
><span class="k">function</span> HtmlAmpersand(){
  Selection.Find.ClearFormatting
  Selection.Find.Replacement.ClearFormatting
  <span class="k">with</span>(Selection.Find){
    Text = <span class="s">"&amp;"</span>;
    Replacement.Text = <span class="s">"&amp;amp;"</span>;
    Forward = <span class="l">true</span>;
    Wrap = wdFindContinue;
    Format = <span class="l">false</span>;
    MatchCase = <span class="l">false</span>;
    MatchWholeWord = <span class="l">false</span>;
    MatchWildcards = <span class="l">false</span>;
    MatchSoundsLike = <span class="l">false</span>;
    MatchAllWordForms = <span class="l">false</span>;
  }
  Selection.Find.Execute(wdReplaceAll);
}
</code></pre>


<h6>HomeSite</h6>
<p>Jedním z posledních poèinù firmy Macromedia ve vıvoji excelentního programu HomeSite,
ne ho z nepochopitelnıch dùvodù pøestala vyvíjet, bylo, e v nìm umonila skriptování.
Jako jazyk byl pouit JavaScript a produktu to dodalo tolik síly a flexibility,
e i bez podpory a dalšího vıvoje ji dva roky pøeívá a tìší se znaèné oblibì u vıvojáøù webovıch aplikací.
</p><p>Následující kratièká ukázka obalí vybranı text HTML elementem <code>&lt;code&gt;</code>:
</p>
<pre><code class="js"><span class="k">function</span> Main(){
  Application.ActiveDocument.InsertTag(<span class="s">'&lt;code&gt;'</span>, <span class="s">'&lt;/code&gt;'</span>, <span class="l">false</span>);
}</code></pre>

<h6>Macromedia Flash</h6>
<p>Jak je popsáno v podkapitole <a href="#k-a-3-8">Provázanost JavaScriptu s Flashem</a>,
firma Macromedia pouívá ve vıvojovém prostøedí pro skriptování JavaScript.
Touto aplikací jsem se ale nezabıval tak hluboko, abych se s jejími skriptovacími monostmi blíe seznámil.
Zájemce odkazuji na uvedené stránky.
</p>

<h6>Adobe Photoshop</h6>
<p>Firma Adobe evidentnì pøešlapovala na místì a nemohla se rozhodnout, jestli tzv. dávky (batches)
zpøístupní jako skripty s textovım zdrojovım kódem, nebo je nadále nechá zahalené.
Celkovı image produktù Adobe byl toti styl myšoklikací aplikace, u které se na klávesnici šahat nesluší.
Proto ve verzi Photoshop 7.0 sice probíhají akce a dávky na bázi JavaScriptu, ovšem v prostøedí programu
o tom není ani zmínky. Pro objevení JavaScriptu musíme jít hluboko do adresáøù programu,
kde v souboru <code>ScriptingListenerJS.log</code> najdeme tøeba takovıto záznam:
</p>
<pre><code class="photoshop block"
>on open fileList
tell application "Adobe Photoshop CS"
activate
set i to count of fileList
repeat i times
set thefile to (item i of fileList)
open thefile showing dialogs never
tell current document
do javascript "{var id110 = charIDToTypeID( \"Lvls\" );
var desc33 = new ActionDescriptor();
var id111 = stringIDToTypeID( \"autoBlackWhite\" );
desc33.putBoolean( id111, true );
var id112 = stringIDToTypeID( \"autoNeutrals\" );
desc33.putBoolean( id112, true);
executeAction( id110, desc33, DialogModes.NO );}"
if (characters -1 thru -3 of thefile = "JPG") then
save as JPEG with options {embed color profile:false,
matte:none, quality:12} without copying
close without saving
else
save
close without saving
end if
end tell
end repeat
end tell
end open</code></pre>

<p>Ovšem u Photoshopu CS je ji situace jiná. Firma Adobe razantnì vyšla vstøíc uivatelùm s programátorskım nadáním
a u všech svıch aplikací nasazuje JavaScript jako jazyk pro skriptování a pro psaní rozšíøení (extensions):
</p>
<blockquote cite="http://thephotofinishes.com/photoshopcs.htm">Now Adobe has taken a longer view of scripting. It recognizes the importance of a scripting tool
	as a means of allowing savvy users and 3rd party tool makers to extend the capabilities of Photoshop
	in very novel ways. For example, automated creation of catalogs is one such application.
	But Adobe needs a cross platform scripting language since VBA does not run on the Mac or a possible new target platform, Linux.
	So Adobe has added JavaScript as its scripting language because it does reach Linux, Mac, Windows and a number of other platforms.
	Users are encouraged to try the <code>File | Script | Browse</code> command and the go to the 
	<code>Program File/Adobe/Photoshop CS/Scripting Guide/Sample Scripts/JavaScripts</code>
	directory and try some of the two dozen simple to complex scripts available there.
	This is the future of the whole line of Adobe products as JavaScript has become the macro
	and extension language for Illustrator, GoLive, Atmosphere, etc.
	<p class="float_right">(ze serveru <a href="http://thephotofinishes.com/photoshopcs.htm">thephotofinishes.com</a>)</p>
</blockquote>

<h6>Jasc Paint Shop Pro</h6>
<p>Jeden z nejlepších konkurentù Photoshopu, editor Paint Shop Pro od firmy Jasc,
co se tıká skriptování, Photoshop pøedbìhl. Ve svojí verzi 9.0 obsahuje povedenı
skriptovací systém. Firma Jasc však nesáhla po JavaScriptu; místo toho vsadila na vlastní
proprietární skriptovací jazyk:
</p>
<pre><code class="paintshoppro block"
>from JascApp import *

# Actually works only on a image in landscape mode 10x15 cm
def ScriptProperties():
  return {
    'Author': 'Jean-Luc Ernst',
    'Copyright': 'Jean-Luc Ernst',
    'Description': "Create a sepia frame from landscape mode",
    'Host': 'Paint Shop Pro',
    'Host Version': '8.00'
  }
  
def Do(Environment):
  App.Do( Environment, 'Copy', {
    'GeneralSettings': {
      'ExecutionMode': App.Constants.ExecutionMode.Default, 
      'AutoActionMode': App.Constants.AutoActionMode.Match
    }
  })
  App.Do( Environment, 'PasteGraphicAsNewImage', {
   'CreateFromDropData': App.Constants.Boolean.false, 
   'GeneralSettings': {
     'ExecutionMode': App.Constants.ExecutionMode.Default, 
     'AutoActionMode': App.Constants.AutoActionMode.Match
   }
 })
...
</code></pre>

<p>Dá se oèekávat, e i firma Jasc nakonec pøejde na JavaScript. Tento kód není od JavaScriptu pøíliš daleko,
je však omezen po procerurální stránce. Jedná se o jednoduchou sekvenci instrukcí.
Spojeno s faktem, e syntaxi JavaScriptu budou brzo znát uivatelé konkurenèních produktù Adobe,
které chce firma Jasc dlouhodobì pøetáhnout k sobì, jednalo by se o logickı krok.
</p>

<a name="k-a-1-3-wsh"></a>
<h6>Windows Scripting Host</h6>
<p>Na závìr se seznámíme s druhım nejvìtším, zároveò však paradoxnì nejménì vyuitım nasazením JavaScriptu:
Skriptovací prostøedek systémù Windows - Windows Scripting Host.

</p><p>Z jistıch dùvodù se Microsoft choval k celkem dobrému skriptovacímu nástroji jako k nechtìnému potomkovi.
Poprvé se objevil na CD u systému Windows 98 SE. Figuroval jako jedna z poloek instalace se struènou popiskou
"Write scripts to help automate tasks in Windows".
Instalace èi neinstalace nemìla na systém ádnı viditelnı dopad.
Spolu s Windows Scripting Host interpreterem se na disk dostal adresáø s asi šesti ukázkovımi skripty velmi špatné
kvality a nicneøíkajícími komentáøi. Dokumentace nikde ádná. Vzhledem k tomu, e tradièní øešení firmy Microsoft
je ovládat skriptem objekty COM, bylo jasné, e i WSH je skuteènì jenom interpreter a velmi tenká skoøápka,
zastøešující však veškeré COM komponenty dostupné v systému. Objekty COM u leckdy dokumentované jsou,
a jádro JavaScriptu Microsoft pouívá všude stejné - v prohlíeèi i na serverovıch aplikacích - bylo tedy jasné,
e i zde se jedná o ji dobøe prozkoumanı JScript (èím se míní zdokumentovanı + jsou známé chyby v implementaci).

</p>
<!-- <div class="float_right" style="margin-bottom: 1em; margin-left: 3ex;">
	<img id="win_scripts" class="border" src="img/win_scripts.gif" alt="Skriptovací technologie ve Windows" width="495" height="406"/>
	<div class="img_popisek center">Obrázek pøevzat ze serveru www.wilsonmar.com.</div>
</div> -->
<img id="win_scripts" class="border right" src="img/win_scripts.gif" alt="Skriptovací technologie ve Windows" width="495" height="406"/>

<p>Pøes všechny pøekáky, a&nbsp;zdálo by se skoro, e&nbsp;proti vùli Microsoftu, si&nbsp;monosti skriptovat všimli
všeteèní kutilové. Jeden z&nbsp;nich, Günter&nbsp;Born, dokonce šel tak&nbsp;daleko, e&nbsp;po&nbsp;dvouletém zkoumání napsal knihu.
Tato kniha se zabıvala WSH&nbsp;verze&nbsp;1. Hned v&nbsp;pøedmluvì se&nbsp;dozvíme monı dùvod,
proè&nbsp;se Microsoft o&nbsp;WSH nikde pøíliš
nešíøil: Nástroj byl plnı chyb, byl nekoncepènì navren a&nbsp;byly s&nbsp;ním nepochopitelné problémy.
Na&nbsp;CD Windows&nbsp;98&nbsp;SE ho&nbsp;nejspíše zaøadili jeho vıvojáøi s&nbsp;tím, e pouití je na&nbsp;vlastní riziko,
a&nbsp;navíc získají cennı ohlas od&nbsp;uivatelù.

</p><p>Jak je však u Microsoftu zvykem, nejene se opìt jednalo o lajdácké polovièaté øešení,
ale ani se nikdo jako obvykle nezabıval bezpeèností - na co také, e.
Toho po nìjaké dobì jeden z kutilù, kteøí WSH dokázali ocenit, rád vyuil k&nbsp;napsání
snad nejslavnìjšího viru v historii Windows, <i>I&nbsp;LOVE&nbsp;YOU</i>. Tento virus byl napsán
právì pro WSH v jazyce Visual Basic Script, a&nbsp;jediné, co staèilo k&nbsp;jeho nevídanému úspìchu,
bylo pár øádek kódu, které pøeètou adresy z adresáøe a rozešlou mailem kopii viru na&nbsp;další adresy.
Pøíjemce vidí I&nbsp;LOVE&nbsp;YOU od známé osoby, nedbá varovného dialogu (jak dùmyslné zabezpeèení!)
a&nbsp;spustí&nbsp;si destruktivní skript. S&nbsp;køíkem po&nbsp;funuse pøišel Microsoft s&nbsp;nápadem,
e <a href="http://msdn.microsoft.com/msdnmag/issues/01/04/wsh/default.aspx">skripty by&nbsp;mohlo bıt dobré také&nbsp;nìjak zabezpeèit</a>.


</p><p>V systému Windows 2000 ji byla verze Windows Scripting Host 2.0. Objevila se i ucelená dokumentace zahrnující jak
<a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/script56/html/js56jsoriJScript.asp">popis jádra JavaScriptu - JScript</a>,
tak <a href="http://www.winguides.com/scripting/reference.php?category=3">nìkolik objektù COM pro základní práci se systémem</a>.
Günter Born vydal druhou knihu, <a href="#zdroj_wsh20">Windows Scripting Host&nbsp;2.0</a>.
WSH se&nbsp;stal plnohodnotnım systémovım skriptovacím nástrojem. Microsoft však, vìdom si toho,
e&nbsp;drtivá vìtšina uivatelù nikdy nebude nic takového potøebovat, nadále WSH nijak nepropaguje
a&nbsp;prostì&nbsp;ho nechává napospas kutilùm.

</p><p>Windows Scripting Host, kromì toho, e je na instalaèních CD systému, je
<a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnanchor/html/scriptinga.asp">ke staení na serveru vırobce</a>.
</p>





<a name="k-a-1-3-xul"></a>
<h5>Tvorba celıch aplikací na základì frameworku pouívajícího JavaScript - Mozilla Framework</h5>

<p>Bìnì prohlíeèe umoòují prostøednictvím skriptù ovládat stránku.
U Nadace Mozilla skripty ovládají aplikaci.

</p><p>S fascinující precizností, návrhovou èistotou a neuvìøitelnì efektivnì se v projektech
jako Firefox, Thunderbird, Camino, Callendar a dalších prolínají technologie
JavaScript, CSS, HTML, XUL a další.

</p><p>Radikální krok uèinili vıvojáøi sdruení Mozilla, kdy se rozhodli pøestat psát
aplikaci urèenou pro více platforem pro kadou platformu z velké èásti znovu.
K tomuto radikálnímu kroku se naskytly vhodné podmínky:
<ul> <li>Nadace Mozilla vznikala na pozùstatcích po vıvojovém tımu firmy Netscape.
</li><li>Na základì analızy stávajícího kódu se rozhodli celı projekt pøepsat.
</li><li>Existovala pomìrnì kvalitní specifikace JavaScriptu a kvalitní interpreter.
</li><li>Vıkon poèítaèù dosáhl úrovnì, kdy je moné celou aplikaci napsat v jazyce vyšší úrovnì.
</li></ul>
Za takové situace se pøímo nabízela myšlenka napsat tzv. framework, podkladovou vrstvu,
která by zprostøedkovávala interakci s hostujícím operaèním systémem na jedné stranì
a zajišovala aplikacím jednotné bìhové prostøedí na druhé stranì.
</p>
<p><img class="border left" src="img/xul_planet.png" alt="XULplanet" width="215" height="65" />
Po èase byla vyvinuta technologie XUL - <a href="http://www.xulplanet.com/">XML User Interface Language</a>.
Její úèel je poskytnout co nejsnazší prostøedek k programování klientskıch aplikací.
Je zaloena na myšlence, e rozhraní aplikace je mono rozdìlit na tøi základní èásti:
<ul style="clear: left;"> <li>Logickou strukturu, tedy hierarchii prvkù uivatelského rozhraní.
</li><li>Look &amp; feel, tedy jak vypadají jednotlivé prvky, typy prvkù, rodiny prvkù, oblasti a celá aplikace.
</li><li>Bussines logic, tedy samotné chování aplikace a interakce prvkù.
</li></ul>
V tomto pohledu je mono aplikaci povaovat za komplexní interaktivní dokument,
a pokud je to dokument, je také mono tak k nìmu pøistupovat pøi jeho vytváøení.

Je zøejmé, e pouze tøetí èást je vhodné popisovat procedurálním programovacím jazykem.
</p><p>Je zøejmé, e pro kadou èást bude vhodnìjší jinı prostøedek, jak ji definovat:
<ul> <li>Logickou strukturu je vhodné popsat opìt logickou strukturou - staèí zvolit jazyk.
</li><li>Look &amp; feel je dobré popsat zpùsobem, kterı by jednak oddìlil strukturu dokumentu od vzhledu,
a jednak byl dostateènì flexibilní, aby dokázal popsat jak jednotlivé konkrétní prvky,
tak rùzné skupiny prvkù, typy prvkù èi prvky v urèité vìtvi dokumentu, a prvky splòující kombinace tìchto kritérií.
</li><li>Bussines logic je samozøejmì vhodné popsat nìjakım procedurálním jazykem.
</li></ul>
No a od této úvahy byl jen kousek k finálnímu øešení:
<ul> <li>Logickou strukturu popisuje XML dokument novì zavedené struktury.
</li><li>Look &amp; feel - zde je volba naprosto jasná - CSS.
</li><li>Bussines logic - zde padla volba logicky na JavaScript.
</li></ul>

</p><p>Všechny tyto èásti byly spojeny do XUL.
Na této technologii pak vıvojáøi postavili všechny aplikace Mozilla.
Celé okno, kadı dialog, kadé menu, tlaèítko, všechno, co se v aplikaci vyskytuje, je popsáno jazykem XUL.
Podoba kadého z tìchto prvkù je urèena kaskádními styly (CSS).
Chování programu ovládá a všechny události obsluhuje JavaScript.

</p><p>Jednotlivé èásti se pak dále rozkládají na mnoho podèástí. Pøi návrhu struktury
bylo pamatováno na maximum potøeb, které se mohou pøi vıvoji aplikace naskytnout:
<ul> <li>Lokalizace (pøeklad)
</li><li>Internacionalizace (pøipravenost k zacházení s národním prostøedím)
</li><li>Dostupnost (napø. postienım)
</li><li>Pøenositelnost (na rùzné platformy)
</li><li>Škálovatelnost
</li><li>Modularizace (oddìlování jednotlivıch èástí)
</li><li>Sdílení uivatelskıch dat a nastavení (profily)
</li><li>Zálohování a obnova
</li><li>Upgradování softwaru
</li><li>Modifikovatelnost (uivatelem, tøetí stranou)
</li><li>Rozšiøitelnost
</li><li>Skinovatelnost - úprava vzhledu (aplikace uivatelem preferovaného vzhledu)
</li></ul>

</p><p>XUL je pøíliš rozsáhlá technologie na to, abychom ji tu 
by jen struènì popsali. Její kompletní rozbor by vydal minimálnì na celou magisterskou práci.
Na serveru XULplanet.org jsou k dispozici <a href="http://www.xulplanet.com/tutorials/xultu/intro.html">srozumitelné tutoriály</a>.
Další <a href="http://www.mozilla.org/xpfe/xptoolkit/xulintro.html">seznámení s XUL</a> je na serveru Mozilla.org.
<!-- V této práci ještì XUL èásteènì pøedstavíme v kapitole <a href="#k-b-3">Mozilla Calendar</a>. -->
</p>

</div>
			</div>
			<div>
				<a name="k-a-1-4"></a>
				<h4>A.1.3. Monosti JavaScriptu pøi dekompozici - vyuití plnì objektového konceptu Javy</h4>
				<div><!-- Úvod / Monosti JavaScriptu pøi dekompozici - vyuití plnì objektového konceptu javy -->


    <p>Pøi návrhu pùvodního JavaScriptu v prohlíeèi Navigator musela firma Netscape
rozhodnout, jak zajistit tomuto jazyku objektové vlastnosti. Nebylo moné pøevzít
sloitı objektovı model Javy - jednak by implementace nebyla jednoduchá,
a jednak bylo tøeba zajistit maximální flexibilitu a jednoduchost zápisu.
Pokud by bylo tøeba pro kadou potøebnou èinnost definovat tøídu a její metody,
vedlo by to k velké neefektivnosti. Proto se k pøistoupilo k jednoduchému konceptu:
V JavaScriptu je vše objekt.

</p><p>Objekt je objekt, funkce (metoda) je objekt, tøída je objekt, pole je objekt, textovı øetìzec je objekt, regulární vıraz je objekt.
Objekt je potom mnoina dvojic název - hodnota. Název je øetìzec a hodnota je skalární promìnná nebo objekt.
Pokud je hodnotou funkce, pak se jedná o metodu. Nyní u se nám vyrısovala základní struktura objektù v JavaScriptu.

</p><p>V této kapitole si ukáeme, jak se v JavaScriptu programují rùzné konstrukce OOP.
Pokusíme se dosáhnout podobnıch efektù, jako v Javì.
</p>


<a name="k-a-1-4-promenne_objektu"></a>
<h5>Èlenské promìnné objektu</h5>
<p>Zde snad není pøíliš co vysvìtlovat. Objekty JavaScriptu mají vlastnosti, co jsou èlenské promìnné.
</p>
<pre><code class="java block"
><span class="cml">// Java</span>
<span class="k">public class</span> cTridaA{
  <span class="k">public int</span> cislo = <span class="n">0</span>;
  <span class="k">public static void</span> Main(){
    cTridaA o = <span class="k">new</span> cTridaA();
    o.cislo = 5;
  }
}</code></pre>

<pre><code class="js block"
><span class="cml">// JavaScriptová obdoba</span>
<span class="k">function</span> cTridaA(){
  <span class="k">this</span>.iCislo = <span class="n">0</span>;
}
<span class="k">var</span> o = <span class="k">new</span> cTridaA();
o.iCislo = <span class="n">5</span>;
</code></pre>


<a name="k-a-1-4-promenne_tridy"></a>
<h5>Promìnné tøídy</h5>
<p>To, èeho se v Javì dosahuje klíèovım slovem <code>static</code>,
toho v JavaScriptu dosáhneme vyuitím faktu, e i funkce je objekt
a mùeme jí tedy pøiøadit libovolné vlastnosti.
</p>

<pre><code class="java block"
><span class="cml">// Java</span>
<span class="k">public class</span> cTridaA{
  <span class="k">public static int</span> cislo = <span class="n">0</span>;
  <span class="k">public static int</span> generuj(){
    <span class="k">return</span> ++<span class="k">this</span>.cislo;
  }
}</code></pre>

<pre><code class="js block"
><span class="cml">// JavaScriptová obdoba</span>
<span class="k">function</span> cTridaA(){
  <span class="k">this</span>.iCislo = <span class="n">0</span>;
}
cTridaA.prototype.Generuj = <span class="k">function</span>(){
  if(undefined == cTridaA.iCislo) cTridaA.iCislo = <span class="n">0</span>;
  <span class="k">return</span> ++cTridaA.iCislo;
}
</code></pre>


<a name="k-a-1-4-konstanty"></a>
<h5>Konstanty tøídy</h5>
<p>Konstanty ve smyslu hodnot, které po jejich definování nelze pøepsat, v JavaScriptu nejsou.
Je zde ovšem monost uloit hodnotu tak, e pokud se jí nìjakı objekt pokusí zmìnit, 
kopie promìnné tøídy se vytvoøí v objektu a pak se zmìní jen tato nová promìnná objektu.
Hodnota promìnné tøídy zùstane stejná. Toto øešení vyuívá prototyp objektu.
</p>

<pre><code class="java block"
><span class="cml">// Java</span>
<span class="k">public class</span> cTridaA{
  <span class="k">public static final int</span> cislo = <span class="n">212</span>;
  <span class="k">public static int</span> getKonst(){
    <span class="k">return</span> <span class="k">this</span>.cislo;
  }
}</code></pre>

<pre><code class="js block"
><span class="cml">// JavaScriptová obdoba</span>
<span class="k">function</span> cTridaA(){
  <!-- <span class="k">this</span>.iCislo = <span class="n">5</span>; -->
}
cTridaA.prototype.iCislo = <span class="n">212</span>;
cTridaA.prototype.GetKonst = <span class="k">function</span>(){
  <span class="k">return this</span>.iCislo;
}

<span class="cml">// Vytvoøíme dva objekty cTridaA</span>
<span class="k">var</span> o1 = <span class="k">new</span> cTridaA();
<span class="k">var</span> o2 = <span class="k">new</span> cTridaA();
<span class="cml">// V jednom z nich zmìníme hodnotu iCislo</span>
o1.iCislo = <span class="n">777678182</span>;
<span class="cml">// Tím se v nìm skuteènì zmìní:</span>
<span class="f">alert</span>(o1.GetKonst());     <span class="cml">// zobrazí 777678182</span>
<span class="cml">// Ale ve druhém zùstala v platnosti "konstanta".</span>
<span class="f">alert</span>(o2.GetKonst());     <span class="cml">// zobrazí 212</span>
</code></pre>



<a name="k-a-1-4-rozklad_do_trid"></a>
<h5>Rozklad do tøíd</h5>
<p>Jak bylo zmínìno vıše, pokud promìnnou definujeme bez pøíslušnosti nìjakému objektu, automaticky se pøiøazuje 
objektu nejvyšší úrovnì. Tímto zpùsobem bychom mohli vytvoøit kód ve stylu napø. Pascalu nepouívající praktiky OOP:
</p>

<pre><code class="js"
><span class="k">function</span> Clovek_GetVek(oClovek){
  <span class="k">return</span> (<span class="k">new</span> Date).getYear() - oClovek.iRokNarozeni;
}

<span class="k">var</span> clovek = <span class="k">new</span> <span class="f">Object</span>();
clovek.sJmeno = <span class="s">"Pepa"</span>;
clovek.iRokNarozeni = <span class="n">1980</span>;
...
<span class="k">var</span> iPepovoVek = Clovek_GetVek(clovek);
</code></pre>

<p>Nìco takového nám Java nedovolí. V Javì musí bıt vše peèlivì <em>protøídováno</em>:
</p>

<pre><code class="java block"
><span class="cml">// Java</span>
<span class="k">public class</span> Clovek {
  <span class="k">private</span> String jmeno;
  <span class="k">private int</span>    rokNarozeni;
  <span class="k">public</span> Clovek(String jmeno, <span class="k">int</span> rokNarozeni){
    <span class="k">this</span>.jmeno = jmeno;
    <span class="k">this</span>.rokNarozeni = rokNarozeni;
  }
  <span class="k">public int</span> getVek(){
    <span class="k">return</span> (new Date()).getYear() - <span class="k">this</span>.rokNarozeni;
  }
}

<span class="k">public class</span> Program {
  public static void main(){
    Clovek clovekPepa = new Clovek(<span class="s">"Pepa"</span>, 1980);
    int    pepovoVek = clovekPepa.getVek();
  }
}
</code></pre>

<p>JavaScript má k vìtšinì moností Javy svùj zpùsob øešení.
Monost rozkladu datového modelu do tøíd je samozøejmostí.
</p>

<pre><code class="js"
><span class="cml">// JavaScriptová obdoba</span>
<span class="k">function</span> Clovek(sJmeno, iVek){
  <span class="k">this</span>.sJmeno = sJmeno;
  <span class="k">this</span>.iRokNarozeni = iRokNarozeni;
}
Clovek.prototype.GetVek = <span class="k">function</span>(){
  <span class="k">return</span> (<span class="k">new</span> Date).getYear() - <span class="k">this</span>.iRokNarozeni;
}

<span class="k">var</span> oClovekPepa = <span class="k">new</span> Clovek(<span class="s">"Pepa"</span>, <span class="n">1980</span>);
<span class="k">var</span> iPepovoVek  = oClovekPepa.GetVek();
</code></pre>



<a name="k-a-1-4-vztah_ma"></a>
<h5>Dekompozice vztahu "má" - vnoøené objekty</h5>
<p>Nejjednodušší vztah v OOP je v JavaScriptu realizován stejnì jako ve mnoha jazycích vnoøením objektù.
Vlastnosti objektu se jednoduše pøiøadí objekt, kterı má bıt jeho souèástí.
</p>

<pre><code class="js"
><span class="cml">// tøída cFaktura - pøedstavuje objekt faktury</span>
<span class="k">function</span> cFaktura(oVystavitel, oPrijemce, iCastka){
  <span class="k">this</span>.oVystavitel = oVystavitel;
  <span class="k">this</span>.oPrijemce = oPrijemce;
  <span class="k">this</span>.iCastka = <span class="n">0</span>;
}
cFaktura.prototype.GetCelkovaCastka() =
  <span class="k">function</span>(){ <span class="k">return this</span>.iCastka; }

<span class="cml">// tøída cFirma - pøedstavuje subjekt na faktuøe</span>
<span class="k">function</span> cFirma(sNazev, oAdresa, sIco){
  <span class="k">this</span>.sNazev  = sNazev;
  <span class="k">this</span>.oAdresa = oAdresa;
  <span class="k">this</span>.sIco    = sIco;
}
<span class="cml">// tøída cAdresa - obsahuje informace o adrese</span>
<span class="k">function</span> cFirma(sUlice, sMesto, sPsc){
  <span class="k">this</span>.sUlice  = sUlice;
  <span class="k">this</span>.sMesto  = sMesto;
  <span class="k">this</span>.sPsc    = sPsc;
}

<span class="cml">// Vytvoøíme vystavitele</span>
<span class="k">var</span> oVystavitel = <span class="k">new</span> cFirma(
  <span class="s">"Dynawest"</span>,
  <span class="k">new</span> cAdresa(<span class="s">"Lannova 1"</span>, <span class="s">"Èeské Budìjovice"</span>, <span class="s">"370 01"</span>),
  <span class="s">"734 98 858"</span>);

<span class="cml">// Vytvoøíme pøíjemce</span>
<span class="k">var</span> oPrijemce   = <span class="k">new</span> cFirma(
  <span class="s">"1. jihoèeská ukázková"</span>,
  <span class="k">new</span> cAdresa(<span class="s">"Lannova 2"</span>, <span class="s">"Èeské Budìjovice"</span>, <span class="s">"370 01"</span>),
  <span class="s">"734 99 001"</span>);

<span class="cml">// Vytvoøíme fakturu s pøíslušnımi subjekty</span>
<span class="k">var</span> oFaktura = <span class="k">new</span> Faktura(oVystavitel, oPrijemce, <span class="n">50000</span>);
</code></pre>

<p>V tomto pøípadì faktura má subjekty. Subjekt je dále rozloen - adresa je další vnoøenı objekt.
</p>



<a name="k-a-1-4-vztah_je"></a>
<h5>Dekompozice vztahu "je" - specializace tøídy (dìdiènost)</h5>
<p>Dìdiènost je v JavaScriptu provedena pomocí prototypù tøíd.
Kadá tøída (tedy funkce, která slouí jako konstruktor) má vlastnost <code>prototype</code>,
v ní je uloen vzorovı objekt, podle nìj se vytváøejí nové instance objektù tøídy.
Pokud tedy vytváøíme specializaci tøídy, pøeneseme schopnosti a vlastnosti bázové tøídy
do odvozené tak, e do její vlastnosti <code>prototype</code> vloíme objekt bázové tøídy.
</p>

<pre><code class="js"
><span class="cml">// Potøebujeme novou tøídu pro poloky. Pro stuènost zkráceno.</span>
<span class="k">function </span>cFakturaPolozka(sNazev, sJedn, dMnoz, iCena){ ... }
cFakturaPolozka.prototype.CenaCelkem = <span class="k">function</span>(){
  <span class="k">return this</span>.dMnozstvi * <span class="k">this</span>.iCenaJedn;
}

<span class="cml">// Nová odvozená tøída - faktura s více polokami</span>
<span class="k">function</span> cFakturaVicePolozek(oVystavitel, oPrijemce, aPolozky){
  <span class="cml">// Zavoláme konstruktor nadøazené tøídy</span>
  <span class="k">this</span>.prototype.constructor.call(oVystavitel, oPrijemce, 0);
  <span class="cml">// Nastavíme konstruktor objektu na tuto tøídu</span>
  <span class="k">this</span>.prototype.constructor = <span class="k">this</span>;
  <span class="cml">// Pøidáme vlastnost - pole poloek</span>
  <span class="k">this</span>.aoPolozky = aPolozky ? aPolozky : <span class="k">new</span> <span class="f">Array</span>();
  <span class="k">this</span>.iCastka = <span class="k">this</span>.SectiCenyPolozek();
}
<span class="cml">// Zdìdìní od tøídy cFaktura</span>
cFakturaVicePolozek.prototype = <span class="k">new</span> cFaktura(null, null);

<span class="cml">// Zjištìní celkové èástky faktury</span>
cFakturaVicePolozek.prototype.SectiCenyPolozek = <span class="k">function</span>(){
  var dCenaCelkem = <span class="n">0</span>;
  <span class="k">for</span>(<span class="k">var</span> i <span class="k">in</span> <span class="k">this</span>.aoPolozky){
    iCenaCelkem += <span class="k">this</span>.aoPolozky[i].CenaCelkem();
  }
  <span class="k">return</span> <span class="f">Math</span>.round(dCenaCelkem);
}

<span class="cml">// Pøidání poloky do faktury</span>
cFakturaVicePolozek.prototype.AddPolozka =
    <span class="k">function</span>(sNazev, sJednotka, dMnozstvi, iCenaJedn){
  var oPolozka =
    <span class="k">new</span> cFakturaPolozka(sNazev, sJednotka, dMnozstvi, iCenaJedn);
  <span class="k">this</span>.aoPolozky.push(oPolozka);
  <span class="k">this</span>.iCastka += oPolozka.CenaCelkem();
}

<span class="cml">// Odebrání poloky z faktury</span>
cFakturaVicePolozek.prototype.RemPolozka = <span class="k">function</span>(iIndex){ ... }

...

</code></pre>

<a name="k-a-1-4-rozhrani"></a>
<h5>Rozhraní (interface)</h5>
<p>Ne si ukáeme, jak v JavaScriptu napodobit funkènost rozhraní,
zeptejme se, jsou-li vùbec tøeba. K èemu jsou v Javì rozhraní?
Slouí ke dvìma úèelùm. Zaprvé je s jeho pomocí vynucována implementace
konkrétních metod, tedy nìco jako abstraktní metody v C++.
Zadruhé slouí jako náhrada polymorfismu a umoòují
pracovat s jakoukoliv tøídou urèitım zpùsobem, pokud potøebné rozhraní implementuje.

</p><p>JavaScript je ale jazyk slabì typovı. Interpreter tedy neví, jestli objekt 
obsahuje danou metodu nebo ne, dokud se ji nepokusí najít. Teprve pøi volání neexistující
metody vyvolá bìhovou chybu. Formálnì deklarovanı typ objektu navíc mùeme sami
libovolnì mìnit zmìnou jeho vlastnosti <code>constructor</code>. Pøiøazením
jakéhosi rozhraní urèité tøídì bychom tedy nièeho nedosáhli.

</p><p>Jak tedy v JavaScriptu zajistit to, co zajišují v Javì rozhraní?
Pro vynucení implementace se mùeme inspirovat v jazyce C++ a jeho abstraktních tøídách.
Vytvoøíme bázovou tøídu, které pøidáme metodu, která bude kontrolovat prototyp tøídy,
jestli obsahuje námi vyadované metody.
</p>
<pre><code class="js block"
><span class="cml">// Bázová tøída - konstruktor; pomocí metody CheckInterface
// zkontrolujeme, zda jsou implementovány metody rozhraní.</span>
<span class="k">function</span> cAbstractClass(){
  <span class="cml">// Pokud konstruujeme prototyp odvozené tøídy, nereagovat:</span>
  <span class="cml">// cImplementingClass.prototype = new cAbstractClass();</span>
  <span class="k">if</span>(<span class="k">this</span>.<span class="k2">constructor</span> != <span class="k2">arguments</span>.callee){
    <span class="k">var</span> asNonImplemented = <span class="k">this</span>.CheckInterface(
      <span class="s">"PrvniPovinnaMetoda DruhaPovinnaMetoda"</span>);
    <span class="k">if</span>( asNonImplemented.length &gt; <span class="n">0</span> )
      alert(<span class="s">"Chyba! Tøída ["</span>+<span class="k">this</span>.<span class="k2">constructor</span>.name+<span class="s">"] "</span>
        +<span class="s">"neimplementuje tyto povinné metody:\n"</span>
        + asNonImplemented.join(<span class="s">"\n"</span>));
  }
}

cAbstractClass.<span class="k2">prototype</span>.CheckInterface = <span class="k">function</span>(saMethods){
  <span class="cml">// this ukazuje na novì vytváøenı objekt.
  // this.constructor na konstruktor odvozené tøídy.
  // Její prototyp musí implementovat potøebné metody.</span>
  <span class="k">var</span> asMustHave = saMethods.split(<span class="s">" "</span>);
  <span class="k">var</span> asNonImplemented = <span class="k">new</span> <span class="f">Array</span>();
  <span class="k">for</span>(<span class="k">var</span> i <span class="k">in</span> asMustHave){
    <span class="k">if</span>(!<span class="k">this</span>.<span class="k2">constructor</span>.<span class="k2">prototype</span>[asMustHave[i]] ||
    <span class="s">"function"</span> != <span class="k">typeof</span> <span class="k">this</span>.<span class="k2">constructor</span>.<span class="k2">prototype</span>[asMustHave[i]])
      asNonImplemented.push(asMustHave[i]);
  }
  <span class="k">return</span> asNonImplemented;
}

<span class="cml">// Odvozená tøída - konstruktor </span>
<span class="k">function</span> cImplementingClass(){
  <span class="cml">// Nejprve zmìníme konstruktor, aby ho konstruktor bázové tøídy
  // mìl k dispozici a znal tøídu vytváøeného objektu.</span>
  <span class="k">this</span>.<span class="k2">constructor</span> = <span class="k2">arguments</span>.callee;
  <span class="cml">// Potom voláme konstruktor bázové tøídy,
  // kterı vyhrabeme z prototypu tøídy cImplementingClass.</span>
  <span class="k2">arguments</span>.callee.<span class="k2">prototype</span>.<span class="k2">constructor</span>.apply(<span class="k">this</span>,<span class="k">this</span>.<span class="k2">arguments</span>);
}
cImplementingClass.<span class="k2">prototype</span> = <span class="k">new</span> cAbstractClass();
cImplementingClass.<span class="k2">prototype</span>.PrvniPovinnaMetoda = <span class="k">function</span>(){}
<span class="cml">// Zámìrnì vynecháme. Pøi konstrukci objektu cImplementingClass
// bychom mìli bıt upozornìni na to, e metoda není implementována.
//cImplementingClass.prototype.DruhaPovinnaMetoda = function(){}</span>

<span class="k">var</span> o;
o = <span class="k">new</span> cImplementingClass();
</code></pre>

<p>Pøíklad najdete v souboru <a href="priklady/p-a-1-4-rozhrani.html">p-a-1-4-rozhrani.html</a>.</p>



<a name="k-a-1-4-baliky"></a>
<h5>Balíky</h5>
<p>Nakonec si pøedvedeme, jak napodobit systém balíkù v Javì.
Jeliko tøída je urèena konstruktorem, konstruktor je funkce, funkce je objekt
a objekt mùe bıt vlastností jiného objektu, mùeme si vytváøet libovolnou hierarchii
objektù, do nich si dáme svoje tøídy:
</p>

<pre><code class="js block"
><span class="cml">// Pøidá do globálního objektu funkce z objektu v parametru</span>
<span class="k">function</span> import(oPackage){
  <span class="k">if</span>(!oPackage || <span class="s">"object"</span> != <span class="k">typeof</span> oPackage)
    <span class="k">return false</span>;

  <span class="k">var</span> iCount = 0;
  <span class="k">for</span>(i <span class="k">in</span> oPackage){
    <span class="k">var</span> oMaybeFunction = oPackage[i];
    <span class="k">if</span>("object" != <span class="k">typeof</span> oMaybeFunction ||
        <span class="f">Function</span> != oMaybeFunction.constructor)
      <span class="k">continue</span>;
    window[i] = oMaybeFunction;
    iCount++;
  }
  <span class="k">return</span> iCount;
}

<span class="cml">// Vytvoøíme si balík javascript.io</span>
<span class="k">var</span> javascript = <span class="k">new</span> <span class="f">Object</span>();
javascript.io = <span class="k">new</span> <span class="f">Object</span>();
javascript.io.cOutputStream = function(sStreamDestination){<span class="cmb">/*...*/</span>}
javascript.io.OutputDebugString = <span class="k">function</span>(s){
  <span class="f">alert</span>(<span class="s">"Ladicí zpráva:\n"</span> + s);
}

<span class="cml">// Importujeme balík</span>
import(javascript.io);

<span class="cml">// Nyní mùeme pouívat funkce a tøídy z balíku.</span>
OutputDebugString(<span class="s">"Importovali jsme funkce z balíku javascript.io."</span>);
<span class="k">var</span> oStream = <span class="k">new</span> cOutputStream(<span class="s">"/dev/null"</span>);
</code></pre>

<p>Tento pokus je tøeba brát s rezervou - nebude to fungovat jako v Javì,
napøíklad funkce z jednoho balíku na sebe "neuvidí". Jako perlièka na závìr kapitoly to ale poslouilo dobøe.
</p></div>
			</div>
			<div>
				<a name="k-a-1-5"></a>
				<h4>A.1.4. Monosti dekompozice s ohledem na kooperativní programování</h4>
				<div><!-- Úvod / Monosti dekompozice s ohledem na kooperativní programování -->

<div class="block quote">
<p>"Kvalitní objektovì orientovanı návrh aplikace je nezbytnım pøedpokladem jeho úspìšné implementace".
Tuto floskuli pravdìpodobnì slyšel kadı, kdo se vıvojem aplikací zabıvá profesionálnì.
I v pøetechnizované IT oblasti je módní pouívat libozvuèná magická zaklínadla,
je mají zákazníka utvrzovat v profesionalitì dodavatele, kterı ale èasto není schopen dostát
nárokùm kvalitního návrhu, zato se brilantnì orientuje v PR frázích a zná nazpamì aktuální slovník buzzwords.
</p>
<p class="popisek">
	Èlánek <a href="http://interval.cz/clanek.asp?article=2783">Návrh aplikací v jazyce UML</a>
	<br/>Server <a href="http://interval.cz/">interval.cz</a>
</p>
</div>

<p>Dekompozice problematiky je záleitost teoretická.
Jedná se o èást teorie vıvoje informaèních systémù.
Tento vìdní obor má ji pomìrnì dlouhou historii,
bìhem které bylo zformulováno mnoho dogmat, mnoho jich bylo zapomnìno,
z nìkterıch se staly marketingové slogany.

</p><p>Tato kapitola se vìnuje dekompozici z hlediska kooperativního programování.
Nebudeme zkoumat postupy pøi návrhu obecnì kvalitní architektury aplikace,
zamìøíme se pouze na ty aspekty dekompozice, které umoòují efektivní rozdìlení práce v tımu programátorù.
</p>


<a name="k-a-1-5-pojmy"></a>
<h5>Pojmy</h5>
<p>Nejprve si pøedstavíme základní pojmy z oblasti teorie projektování IS.
</p>

<p><strong>Metodika vıvoje</strong> je doporuèenı souhrn etap, pøístupù, zásad, postupù, pravidel, metod, technik, nástrojù, dokumentù a metod øízení.
</p>
<!-- <ul> <li>etap,
</li><li>pøístupù,
</li><li>zásad,
</li><li>postupù,
</li><li>pravidel,
</li><li>metod,
</li><li>technik,
</li><li>nástrojù,
</li><li>dokumentù
</li><li>metod øízení
</li></ul> -->

<p>Pro tvùrce IS, kterı pokrıvá celı ivotní cyklus IS</p>
<ul> <li>urèuje <em>kdy, kdo, co a proè má dìlat</em> bìhem vıvoje a provozu IS
</li><li>je základním standardem, návodem postupù spojenıch s tvorbou IS
</li><li>vztahuje se na
	<ul> <li>pracovníky vıvoje
	</li><li>organizaci práce
	</li><li>práci s informacemi o vyvíjeném IS
	</li><li>SW a HW prvky
	</li><li>ekonomické otázky vıvoje IS
	</li><li>projektovou a provozní dokumentaci k IS
	</li><li>zpùsob øízení v jednotlivıch fázích vıvoje IS
	</li></ul>
</li></ul>

<p><strong>Metoda</strong></p>
<ul> <li>urèuje, <em>co</em> je tøeba dìlat v urèité fázi ivotního cyklu IS
</li><li> je vdy spojena s urèitım pøístupem (funkèní, datovı, objektovı)
</li></ul>

<p><strong>Technika</strong></p>
<ul> <li>urèuje, <em>jak</em> se dobrat poadovaného vısledku
</li><li>pøesnı postup krokù
</li><li>zpùsob pouití nástrojù apod.
</li><li>napø. prototypování, normalizace datového modelu
</li></ul>

<p><strong>Nástroj</strong></p>
<ul> <li>je prostøedkem k uskuteènìní urèité èinnosti
</li><li>k vyjádøení vısledku dané èinnosti &ndash; formalizuje vyjádøení
</li><li>èasto svázán s konkrétní technikou
</li><li>napø. DFD, ERD, STD, ... 
</li><li>CASE nástroje
</li></ul>

<p><strong>Vztah metodiky, metod, technik a nástrojù</strong></p>
<ul> <li>není moné prohlásit, e jednotlivé metody patøí jednoznaènì dané metodice apod.
</li><li>nìkteré metody specifické - vyuívané urèitımi metodikami
</li><li>nìkteré metody univerzální - odkazují se na nì rùzné metodiky, v rùznıch fázích vıvoje IS
</li><li>obdobnì je tomu s technikami a nástroji
</li></ul>


<p><strong>"Strom" vıvojáøù</strong></p>
<p>Pro realizaci projektu je urèen tım. Ten bude rozdìlen do skupin,
z nich se kadá bude zabıvat èástí projektu. Skupiny mohou bıt dìleny dále atd.
Vısledná struktura nemusí bıt stromová, pro zjednodušení ji však nazvìme <em>strom programátorù</em>.
Kadı uzel takového stromu nazveme tım.
</p>

<a name="k-a-1-5-hranice"></a>
<h5>Hranice pùsobnosti</h5>
<p>Nejdùleitìjší pøi rozdìlování realizace jednotlivıch èástí aplikace
je jednoznaèné urèení pole pùsobnosti kadému tımu.
Pøedpokládejme, e jsme provedli abstraktní návrh struktury systému.
Organizace stromu bude pravdìpodobnì reflektovat tuto strukturu &ndash;
kadou èást aplikace tvoøící vìtší logickı celek bude programovat jeden tım.
Podèásti této èásti budou realizovat podmnoiny z tımu, atd.
Aby byla realizace takto hierarchizovaného projektu  moná,
je nutné kadému tımu zadat ohranièenou èást se specifikací jejího poadovaného chování.

</p><p>Metodiky èlenìní IS a navrhování IS obecnì jsou pøíliš rozsáhlou
problematikou a jejich vysvìtlení by bylo nad rámec této práce.
Zájemci si mohou pøeèíst nìkolik èesky psanıch knih.
Rád bych však citoval z <a href="http://interval.cz/clanek.asp?article=2783">èlánku na serveru interval.cz</a>.
Citát se sice tıká UML, ale obsaená myšlenka platí obecnì o nástrojích pomáhajících pøi analıze a návrhu IS.
</p><p class="block quote">
UML je jazyk, kterı umoòuje modelovat jednoduché i sloité aplikace pomocí stejné formální syntaxe,
a proto mùete vısledky své práce sdílet s ostatními návrháøi.
UML ale není všemocné. I kdy umíte UML, ovládáte pouze nástroj. Sice velmi vıkonnı, ale stále jen nástroj –
ty, kteøí si myslí, e UML je cizokrajné koøení, které pouijí na dokrvení svıch anemickıch návrhù, musím zklamat.
Znalcem UML se èlovìk stává, návrháøem èi analytikem se rodí.
</p>

<h6>Pøíklad</h6>
<p>Pøedpokládejme, e tvoøíme aplikaci na vzdálenou správu strojù v továrnì.
Aplikace má dvì hlavní èásti &ndash; serverovou a klientskou.
</p><p>
<p><em>Serverová èást</em></p>
<ul> <li>Má shromaïovat data ze strojù a na vyádání je pøeposlat klientské èásti,
a té zprostøedkovávat ovládání strojù.
</li><li>Má poloautomaticky øídit èinnost strojù a reagovat na mimoøádné situace podle expertního systému.
</li><li>Monosti ovládání je potøeba regulovat pomocí systému práv.
</li><li>Namìøené hodnoty mají bıt archivovány pro tvorbu statistik.
</li><li>Pøijaté pøíkazy a provedené akce se mají zaznamenávat pro monost pozdìjší revize.
</li><li>Má umìt exportovat archivovaná data ve formátu XML.
</li><li>Stroje se serverem komunikují pøes protokol TCP/IP v proprietárním formátu.
</li></ul>


<p><em>Klientská èást</em></p>
<ul> <li>Má bıt schopná prezentovat data ve formì textu, tabulek, grafù a grafické reprezentace strojù.
</li><li>Má také umoòovat poloautomatické øízení strojù.
</li><li>Má poskytnout rozhraní pro správu strojù.
</li><li>Má uládat pøijatá data pro pouití off-line.
</li><li>Vyslané pøíkazy mají bıt archivovány pro monost pozdìjší revize.
</li><li>Má umìt exportovat archivovaná data ve formátu XML.
</li></ul>

<p><em>Spoleèné rysy</em></p>
<ul> <li>Komunikace mezi klientem a serverem má probíhat šifrovanì pøes protokol TCP/IP ve formátu XML.
</li></ul>

<p>Z poadavkù je na první pohled vidìt, e urèitì budou vytvoøeny serverová èást a klientská èást.
Na druhı pohled je mono si všimnout, e nìkolik èástí by mohlo bıt spoleènıch.
Obì èásti mají mít schopnost poloautomatického øízení,
obì budou komunikovat protokolem TCP/IP, obì budou pøenášená data šifrovat.
Realizaci tedy mùeme rozdìlit na nìkolik oddìlenıch èástí:
</p>
<ul> <li>serverová aplikace
</li><li>klientská aplikace
</li><li>modul pro export dat
</li><li>modul pro poloautomatické øízení
</li><li>modul pro transparentní šifrovanou komunikaci pøes TCP/IP
</li><li>modul pro práci s XML
</li><li>pro archivaci dat, zaznamenávání pøíkazù a provedenıch akcí, uloení práv a nastavení atd. bude pouita relaèní databáze
</li></ul>
<p>Pro poslední ètyøi moduly je mono pouít existující kvalitní nástroje,
a z ekonomického hlediska je vıhodnìjší je pouívat ne tvoøit nové.
Proto se jedná pouze o jejich zaèlenìní do aplikace.
Zbylé èásti návrh je mono dále dìlit:</p>
<ul> <li>serverová aplikace
	<ul> <li>modul pro komunikaci s klienty
	</li><li>modul pro administraci a aplikaci pøístupovıch práv
  </li><li>bude pouita databáze &ndash; pro archivaci zjištìnıch hodnot, provedenıch akcí atd.
  </li><li>bude pouit modul pro šifrovanou komunikaci pøes TCP/IP
  </li><li>bude pouit modul pro poloautomatické øízení
  </li><li>bude pouit modul pro práci s XML
  </li></ul>
</li><li>klientská aplikace
	<ul> <li>klientské rozhraní
	</li><li>modul pro vykreslování grafù
	</li><li>modul pro grafickou prezentaci pøijatıch hodnot
	</li><li>bude pouita databáze &ndash; pro uloení pøijatıch hodnot.
	</li><li>bude pouit modul pro šifrovanou komunikaci pøes TCP/IP
  </li><li>bude pouit modul pro poloautomatické øízení
  </li><li>bude pouit modul pro práci s XML
	</li></ul>
</li></ul>

<p>Podle toho hrubého schématu aplikace je pak mono svìøit jednotlivım
tımùm realizaci konkrétních èástí.
</p>


<a name="k-a-1-5-komunikace"></a>
<h5>Komunikace</h5>
<p>Pokud se mají vısledky práce jednotlivıch tımù, tedy èásti aplikace, spojit v celistvı informaèní systém,
musí mezi sebou komunikovat. V té vìtì je nejednoznaènost, ale oba vıznamy platí:
Komunikovat mezi sebou musí jak programátoøi, tak èásti informaèního systému.
</p>

<h6>Komunikace programátorù</h6>
<p>Komunikace programátorù se tıká komunikace èástí. Jinımi slovy, programátoøi
se musí dohodnout na zpùsobu, jak budou èásti aplikace spolupracovat.
Pochopitelnì to neprobíhá tak, e se sejdou u piva a kolem pùlnoci se shodnou na rozhraní.
Prostøedkem komunikace mezi programátory je dokumentace.
</p>

<h6>Komunikace èástí informaèního systému</h6>
<p>Komunikace mezi èástmi IS mùe mít velmi rùznorodé podoby - záleí na úrovni.
Klient se serverem bude pravdìpodobnì komunikovat pøes LAN protokolem TCP/IP nebo podobnım zpùsobem.
IS sestávající z nìkolika aplikací na jednom poèítaèi pouije nìkterou z moností
operaèního systému pro meziprocesovou komunikaci, vlákna obdobnì.
Nás z hlediska JavaScriptu bude zajímat hlavnì ta nejtìsnìjší moná provázanost &ndash;
komunikace èástí aplikace na úrovni zdrojového kódu.

</p><p>A u se však komunikace tıká kterékoliv úrovnì, je tøeba do detailu specifikovat,
jak má komunikace probíhat. K tomu se obvykle na rùznıch vrstvách pouívají tyto prostøedky:
</p>
<ul> <li>Pro síovou komunikaci se definuje síovı protokol.
</li><li>Pro komunikaci procesù se vybírá zpùsob pøedání dat a formát dat.
</li><li>Vlákna vyuívají prostøedky operaèního systému pro synchronizaci vláken a data se ukládají
do spoleènıch datovıch struktur.
</li><li>Na úrovni zdrojového kódu se specifikují poadavky na implementaci (rozhraní)
nebo rovnou celá vnìjší objektová struktura (definice tøídy - veøejnıch metod, konstant a promìnnıch).
</li></ul>


<!-- <h5>Dekompozice a dìlba práce pøi pouití JavaScriptu</h5> -->
<a name="k-a-1-5-komunikace_js"></a>
<h5>Komunikace pøi pouití JavaScriptu</h5>
<p>JavaScript jako obecnì pouitelnı objektovì orientovanı jazyk mùe
øešit všechny typy vztahù mezi èástmi aplikace a všechny typy jejich vzájemné komunikace.
Staèí, kdy má pro danou úlohu dostateèné prostøedky.
</p>

<h6>Síová komunikace</h6>
<p>Jako pøíklad síové komunikace mùe slouit tøída
<a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/xmlsdk/html/xmobjxmlhttprequest.asp"
><code>HttpRequest</code> z MSXML API</a>. Zajišuje sice jen specializovanou
komunikaci pøes protokol HTTP, a to ještì velmi omezenì, ale podobnì by se dala realizovat
i komunikace pomocí socketù.
</p>
<pre><code class="js block"
><span class="k">function</span> PostOrder(sXmlDoc){
  <span class="k">var</span> xmlHttpReq = <span class="k">new</span> ActiveXObject(<span class="s">"Microsoft.XMLHTTP"</span>);
  xmlHttpReq.Open(<span class="s">"POST"</span>, <span class="s">"http://www.dynawest.cz/"</span>, <span class="l">false</span>);
  xmlHttpReq.Send(xmlDoc);
  <span class="k">return</span> xmlHttpReq.responseXML;
}
</code></pre>

<h6>Komunikace mezi procesy</h6>
<p>Komunikace mezi procesy pravdìpodobnì v JavaScriptu ještì nebyla implementována &ndash;
není to moc tøeba, protoe pojem proces JavaScript nerozeznává.
Rùzné implementace øeší tento problém tak, e do prostøedí skriptù
dají reference na rùzné globální objekty (které vıznamem zhruba odpovídají procesùm v operaèním systému) &ndash;
napøíklad prohlíeèe nastavují objektu <code>window</code>
vlastnosti <code>parent</code>, <code>frames[]</code>, <code>opener</code> a <code>self</code>.
</p><p>Rùzné bìící skripty by však mohly komunikovat i bez této pomoci.
Pokusíme se vyuít prostøedkù, které má k dispozici Windows Script Host
(viz kapitola <a href="#k-a-1-3-wsh">Monosti uplatnìní JavaScriptu</a>).
Komunikaci realizujeme mechanismem vımìny dat prostøednictvím souborového systému,
semaforu a mutexu (vıhradního pøístupu). Semafor a mutex realizujeme polokou v registru systému Windows.
Vıhradní pøístup k atomickım polokám registru garantuje operaèní systém.
</p>
<pre><code class="js block"
><span class="k">var</span> oSemafor = <span class="k">new</span> cSemafor(<span class="s">"semafor1"</span>, <span class="n">0</span>);
<span class="k">var</span> oDataStore = <span class="k">new</span> cDataStore(<span class="s">"WSH_DataStore.txt"</span>);

<span class="k">function</span> ProcesPriprava(){
  <span class="k">var</span> bPokracuj = <span class="l">true</span>;
  <span class="k">while</span>(bPokracuj){
    <span class="cml">// Poèkáme, dokud nám druhı proces nesdìlí, e si data vybral.</span>
    <span class="k">while</span>(<span class="n">1</span> == oSemafor.Get()) WScript.Sleep(<span class="n">100</span>);
    
    <span class="k">var</span> sData = MSIE.prompt();
    <span class="k">if</span>(sData == <span class="l">null</span>){ bPokracuj = <span class="l">false</span>; oSemafor.Set(<span class="n">2</span>); <span class="k">break</span>; }
    oDataStore.out.Write(sData);    
    
    <span class="cml">// Sdìlíme druhému procesu, e jsou data pøipravena</span>
    oSemafor.Set(<span class="n">1</span>);
  }
}

<span class="k">function</span> ProcesCteni(){
  <span class="k">var</span> bPokracuj = <span class="l">true</span>;
  <span class="k">while</span>(bPokracuj){
    <span class="cml">// Poèkáme, dokud nám druhı proces nesdìlí, e data pøipravil.</span>
    <span class="k">while</span>(<span class="n">0</span> == oSemafor.Get()) WScript.Sleep(<span class="n">100</span>);
    <span class="k">if</span>(<span class="n">2</span> == oSemafor.Get()){ bPokracuj = <span class="l">false</span>; <span class="k">break</span>; }
    
    <span class="k">var</span> sData = oDataStore.inp.ReadAll();
    <span class="cml">// ... zpracování dat </span>
    
    <span class="cml">// Sdìlíme druhému procesu, e byla vybrána</span>
    oSemafor.Set(<span class="n">0</span>);
  }
}
</code></pre>
<p>Vytvoøí se dvì instance skriptu, jedna s bìící funkcí <code>ProcesCteni()</code> a jedna s <code>ProcesPriprava()</code>.
Pomocí semaforu si navzájem oznamují svùj stav. <code>ProcesPriprava()</code> pøipraví data, uloí je do souboru,
nastaví semafor na hodnotu 1 (pøipraveno), a èeká, a <code>ProcesCteni()</code> data vyzvedne a nastaví semafor zpìt na 0.
U <code>ProcesCteni()</code> je to naopak &ndash; èeká se, a <code>ProcesPriprava()</code> dokonèí pøípravu a nastaví semafor na 1.
Poté vyzvedne data a semafor nastaví opìt na 0. Zatímco se tedy data zpracovávají v <code>ProcesCteni()</code>,
v <code>ProcesPriprava()</code> ji mohou bıt pøipravována další data.
Celı zdrojovı kód tohoto pokusu najdete v souboru <code>priklady/p-a-1-5-procesy.js</code>.</p>

<h6>Komunikace mezi vlákny</h6>
<p>Dosud ádná implementace JavaScriptu nepracuje s vlákny.
Pokud se nìkdy v budoucnu podpora vláken v JavaScriptu objeví, bude pravdìpodobnì fungovat podobnì jako v Javì.</p>

<h6>Komunikace na úrovni kódu</h6>
<p>Komunikace na úrovni kódu se uskuteèòuje voláním funkcí a metod.
Které funkce èi metody a kdy a jak volat je vìcí návrhu aplikace.
JavaScript pro tuto úroveò komunikace poskytuje dostateèné prostøedky &ndash;
 viz kapitola <a href="#k-a-1-4">Monosti JavaScriptu pøi dekompozici</a>.
</p><p>Nejlepším dùkazem schopnosti JavaScriptu zajišovat komunikaci na úrovni kódu
jsou <a href="http://www.mozilla.org/products/">projekty Nadace Mozilla</a> vyvíjené stovkami vıvojáøù po celém svìtì.
Více viz podkapitola <a href="#k-a-1-3-xul">Tvorba celıch aplikací na základì frameworku pouívajícího JavaScript</a>

</p></div>
			</div>
		</div>
		
		<div>
			<a name="k-a-2"></a>
			<h3>A.2. Struènı popis jádra jazyka JavaScript</h3>
			<div>
				<a name="k-a-2-1"></a>
				<h4>A.2.1. Syntaxe</h4>
				<div><!-- Struènı popis jádra jazyka JavaScript / Syntaxe, konstrukce -->


<p>Syntaxe JavaScriptu je odvozená od jazyka Java.
Celková stavba jazyka, jednotlivıch vırazù a mnoho konstrukcí je proto podobnıch. 

</p><p>JavaScript pro interní reprezentaci øetìzcù pouívá
<a target="_blank" href="http://www.unicode.org/unicode/standard/versions/">Unicode</a>,
konkrétnì <a target="_blank" href="http://en.wikipedia.org/wiki/UTF-16">UTF-16</a>.
Kadı znak je tedy reprezentován dvìma bajty. To umoòuje JavaScriptu pouívat
jakékoliv znaky obsaené v normì UTF-16 a otevírá tak cestu k jednoduché internacionalizaci.
Pro programátora neznamená Unicode nevıhodu - zdrojovı kód se zapisuje v jakémkoliv
kódování, které je pøi naètení internì pøevedeno do UTF-16.
</p>

<h5>Velikost písmen</h5>
<p>JavaScript rozlišuje velikost písmen.
Obecnì, všechny znaky sady UTF-16 povauje za unikátní a nezamìnitelné.
Napøíklad pokud definujete dvì promìnné, jednu pojmenujete "ilona" a druhou "Ilona", bude se jednat o dvì nezávislé promìnné.
Všechna klíèová slova jsou psána malımi písmeny
(<code>if</code>, <code>else</code>, <code>for</code>, <code>while</code>, <code>do</code>, <code>function</code>...).

<h5>Bílé znaky</h5>
</p><p>Mezery a konce øádkù mezi tokeny (èástmi kódu) neovlivòují vıznam kódu. Celı program by tedy mohl bıt napsán na jediném øádku.
Jsou dvì vıjimky, kdy vıznam kódu mohou ovlivnit konce øádkù:
První je konec øádku za pøíkazem.
Pravdìpodobnì z historickıch dùvodù umoòuje JavaScript vynechávat za pøíkazy støedníky.
Tato monost však vede k syntaktickım chybám a neoèekávanému chování, proto v této práci není pouívána.
Tato vlastnost s sebou ovšem i tak nese riziko: JavaScript dosazuje støedník tam,
kde se obsah øádku jeví jako úplnı pøíkaz. Ze zápisu
<pre><code class="js block"
><span class="k">return</span>
<span class="l">true</span><span class="o">;</span></code></pre>
se tedy stává
<pre><code class="js block"
><span class="k">return</span><span class="o">;</span>
<span class="l">true</span><span class="o">;</span></code></pre>
Druhou vıjimkou je jednoøádkovı komentáø (viz dále).

<h5>Komentáøe</h5>
</p><p>JavaScript pøebírá syntaxi komentáøù z jazyka C. Jsou tedy dva typy:
	<ul> <li>Øádkovı komentáø zaèíná dvìma lomítky a konèí koncem øádku:
		<pre><code class="js small_icon">iDaysLeft<span class="o">--;</span> <span class="cml">// o další den ke státnicím blíe</span></code></pre>
	</li><li>Blokovı komentáø zaèíná dvojicí znakù "<code>/*</code>" a konèí dvojicí znakù "<code>*/</code>" :
<pre><code class="js"
><span class="cmb">/** Provede sloitı vıpoèet a vrátí vısledek */</span>
<span class="k">function</span> Secti<span class="o">(</span>iA<span class="o">,</span> iB<span class="o">){</span> <span class="k">return</span> iA <span class="o">+</span> iB<span class="o">; }</span></code></pre>
	</li></ul>
	JavaScript sice nerozlišuje dokumentaèní komentáø jako Java,
	ale i v Javì se jedná o rozlišení pro nástroj JavaDoc, nikoliv pro pøekladaè.
	Jeliko nìkteré editory zahrnují podobnı nástroj, a také pro odlišení
	dùleitìjších komentáøù, pouíváme nìkde Javovskı dokumentaèní komentáø.
</p>

<h5>Literály</h5>
<p>Literály reprezentují datové hodnoty, které jsou urèeny pøímo v kódu. Pøíklady literálù:
<pre><code class="js"
><span class="n">212</span>            <span class="cml">// èíslo</span>
<span class="n">2.12</span>           <span class="cml">// èíslo</span>
<span class="s">"Ahoj lidi!"</span>   <span class="cml">// textovı øetìzec</span>
<span class="l">true</span>           <span class="cml">// logická hodnota true</span>
<span class="l">false</span>          <span class="cml">// logická hodnota false</span>
<span class="re">/ahoj/g</span>        <span class="cml">// regulární vıraz</span>
<span class="l">null</span>           <span class="cml">// speciální hodnota null</span>
<span class="o">{</span> jmeno<span class="o">:</span> <span class="s">"Ilona"</span><span class="o">,</span> titul<span class="o">:</span> <span class="s">"Ing"</span> <span class="o">}</span>           <span class="cml">// literál objektu</span>
<span class="o">[</span> <span class="s">1</span><span class="o">,</span> <span class="s">"osm"</span><span class="o">,</span> <span class="s">3.14</span> <span class="o">]</span>                         <span class="cml">// literál pole</span>
</code></pre>
</p>

<h5>Identifikátory</h5>
<p> Identifikátory JavaScriptu zaèínají písmenem nebo podtrítkem a dále pokraèují písmeny, èíslicemi nebo podtrítkem.
Nìkteré identifikátory jsou vyhrazeny JavaScriptem jako tzv. klíèová slova, napø.
<code>if</code>, <code>for</code>, <code>while</code>, <code>function</code> a podobnì.
Seznam rezervovanıch identifikátorù je ve <a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">specifikaci</a>.
</p>


</div>
			</div>
			<div>
				<a name="k-a-2-1b"></a>
				<h4>A.2.2. Konstrukce</h4>
				<div><p>JavaScript pøebírá konstrukce z jazykù C++ a Java.
Princip jejich pouití je stejnı, nicménì v detailech se mírnì liší.
Zájemci o podrobnosti nech si laskavì pøeètou vynikající knihu <a href="#zdroj_javascript">JavaScript - kompletní prùvodce</a>.
My si je zde pøedstavíme jen struènì.

<ul> <li>Podmínka, vèetnì druhé èásti
<pre><code class="js small_icon"><span class="k">if</span><span class="o">(</span> <i>podmínka</i> <span class="o">)</span> <i>pøíkaz</i><span class="o">;</span> <span class="k">else</span> <i>pøíkaz</i><span class="o">;</span> </code></pre>
</li><li>Podmínìnı cyklus s testováním podmínky na zaèátku
<pre><code class="js small_icon"><span class="k">while</span><span class="o">(</span> <i>podmínka</i> <span class="o">)</span> <i>pøíkaz</i><span class="o">;</span></code></pre>
</li><li>Podmínìnı cyklus s testováním podmínky na konci
<pre><code class="js small_icon"><span class="k">do</span> <i>pøíkaz</i><span class="o">;</span> <span class="k">while</span><span class="o">(</span> <i>podmínka</i> <span class="o">)</span><span class="o">;</span> </code></pre>
</li><li>Vìtvení podle hodnoty
<pre><code class="js"><span class="k">switch</span><span class="o">(</span> <i>vıraz</i> <span class="o">){</span>
  <span class="k">case</span> vıraz<span class="o">:</span> <i>pøíkaz</i>; <span class="k">break</span><span class="o">;</span>
  ...
  <span class="k">default</span><span class="o">:</span> <i>pøíkaz</i>; <span class="k">break</span><span class="o">;</span>
<span class="o">}</span></code></pre>
</li><li>Podmínìnı cyklus s inicializací a akcí pøi po prùchodu
<pre><code class="js"><span class="k">for</span><span class="o">(</span> <i>inicializace</i><span class="o">;</span> <i>podmínka</i><span class="o">;</span> <i>akce</i> <span class="o">)</span>
  <i>pøíkaz</i><span class="o">;</span></code></pre>
</li><li>Iterace
<pre><code class="js"><span class="k">for</span><span class="o">(</span> <span class="k">var</span> <i>promìnná</i> <span class="k">in</span> <i>objekt</i> <span class="o">)</span>
  <i>pøíkaz</i><span class="o">;</span></code></pre>
</li><li>Explicitní inicializace promìnné
<pre><code class="js small_icon"><span class="k">var</span> <i>promìnná</i> <span class="o">=</span> <i>vıraz</i><span class="o">;</span></code></pre>

</li><li>Definice funkce
<pre><code class="js small_icon"><span class="k">function</span> <i>název</i> <span class="o">(</span> <i>parametry</i> <span class="o">)</span> <span class="o">{</span> <i>pøíkazy</i> <span class="o">}</span></code></pre>

</li><li>Zachytávání vıjimek
<pre><code class="js"><span class="k">try</span><span class="o">{</span> <i>pøíkazy</i> <span class="o">}</span>
<span class="k">catch</span><span class="o">(</span> <i>promìnná</i> <span class="o">)</span><span class="o">{</span> <i>pøíkazy</i> <span class="o">}</span>
<span class="k">finally</span><span class="o">{</span> <i>pøíkazy</i> <span class="o">}</span>
</code></pre>
</li></ul>

K tìmto konstrukcím patøí ještì další klíèová slova jako <code>throw</code>,
<code>break</code>, <code>continue</code> a <code>return</code>.
Jejich vıznam se opìt od Javy mírnì liší - mají flexibilnìjší pouití.

</p></div>
			</div>
			<div>
				<a name="k-a-2-2"></a>
				<h4>A.2.3. Datové typy, promìnné</h4>
				<div><!-- Struènı popis jádra jazyka JavaScript / Syntaxe, konstrukce -->

<p>JavaScript je tzv. slabì typovı jazyk. To znamená, e promìnná sice vnitønì nese informaci o svém typu,
ale je mono ji pouít kdekoliv. JavaScript toti nemá v kódu explicitnì oznaèované typy promìnnıch,
logicky tedy ani neprovádí kontrolu typù pøi analıze pøeparsovaného kódu. Pøi operacích vyadujících konkrétní typ
zkouší tyto promìnné pøetypovat podle pomìrnì sloitıch pravidel, a a v pøípadì, e pøetypování sele,
je vyvolána bìhová chyba.
</p>

<h5>Datové typy</h5>
<p>JavaScript má datovıch typù oproti jinım jazykùm minimálnì. Jsou tyto:</p>
<ul>
	<li>èísla &ndash; JS nemá speciální typ pro celá èísla. Ta jsou reprezentovaná jako èísla s&nbsp;desetinnou èástí rovnou nule.</li>
	<li>logické hodnoty &ndash; <code>true</code> nebo <code>false</code></li>
	<li><code>undefined</code> &ndash; speciální typ pouívanı k oznaèení nedefinovanıch promìnnıch.</li>
	<li><code>null</code> &ndash; speciální typ pouívanı k oznaèení prázdné promìnné</li>
	<li>objekty &ndash; v JS je skoro vše objekt: objekty, pole, funkce, stringy, regulární vırazy... </li>
</ul>


<p>Další rozlišování jakoby typù u probíhá na úrovni objektù: øetìzce jsou objekty vytvoøené konstruktorem <code>String</code>,
zkrácenì objekty tøídy <code>String</code>, funkce (metody) jsou objekty tøídy <code>Function</code>,
pole je objekt tøídy <code>Array</code>, atd.
Nakonec i èísla bychom mohli pøi zjednodušeném pohledu povaovat za objekty.
Navádí k tomu napø. monost pøevádìt promìnné obsahující èíslo na øetìzec s vyjádøením v jiné soustavì:
</p>

<pre><code class="js"><span class="k">var</span> iVek <span class="o">=</span> <span class="n">25</span><span class="o">;</span>
<span class="k">var</span> sVekBin <span class="o">=</span> iVek<span class="o">.</span>toString<span class="o">(</span><span class="n">2</span><span class="o">);</span> <span class="cml">// 11001</span>
</code></pre>

<p>Toto chování zajišuje mechanismus automatického pøetypování primitivních typù na objekty tzv. obálek primitivních typù&nbsp;-
viz podkapitola <a href="#k-a-2-6-obalky">Obálky primitivních typù</a>.
V ukázce je promìnná typu <i>number</i> pøevedena na objekt tøídy <code>Number</code>.

</p><p>K urèení typu promìnné slouí operátor <code class="jsl"><span class="k">typeof</span> <i>promìnná</i></code>,
kterı vrací podle typu jeden z øetìzcù "boolean", "number", "string", "object". 
</p>

<h5>Maïarská notace</h5>
<p>V této práci se dríme tzv. <i>maïarské notace</i>, tedy pøed název promìnné dáváme budoucímu luštiteli kódu nápovìdu,
jakı typ by se v promìnné mìl pøechovávat. Na&nbsp;základì toho je pak snazší objevit logické chyby v programu.
Zápis tedy vypadá takto:

<pre><code class="js"
><span class="k">var</span> iPocet = <span class="n">212</span>;            <span class="cml">// i jako integer</span>
<span class="k">var</span> fTeplota = <span class="n">2.12</span>;         <span class="cml">// d jako double</span>
<span class="k">var</span> sPozdrav = <span class="s">"Ahoj lidi!"</span>; <span class="cml">// s jako string</span>
<span class="k">var</span> bNalezeno = <span class="l">true</span>;        <span class="cml">// b jako boolean</span>
<span class="k">var</span> rPozdrav = <span class="re">/ahoj/g</span>;      <span class="cml">// r jako regulární vıraz</span>
<span class="k">var</span> oIlona = { jmeno: <span class="s">"Ilona"</span>, titul: <span class="s">"Ing."</span> };   <span class="cml">// o jako objekt</span>
<span class="k">var</span> a = [ <span class="s">1</span>, <span class="s">"osm"</span>, <span class="s">3.14</span> ];                       <span class="cml">// a jako array</span>
</code></pre>

Pole jsou èasto zamıšlena pro jeden typ. V tom pøípadì si mùeme pøedponu rozvinout o typ prvkù:

<pre><code class="js"
><span class="cml">// ai jako array of integers</span>
<span class="k">var</span> ai = [ <span class="n">1</span>, <span class="n">2</span>, <span class="n">4</span>, <span class="n">8</span> ];
<span class="cml">// ai jako array of objects</span>
<span class="k">var</span> ao = [ { jmeno: <span class="s">"Ilona"</span>, titul: <span class="s">"Ing."</span> },
           { jmeno: <span class="s">"Míša"</span>, titul: <span class="s">""</span> } ];
</code></pre>

</p>
</div>
			</div>
			<div>
				<a name="k-a-2-3"></a>
				<h4>A.2.4. Funkce</h4>
				<div><!-- Struènı popis jádra jazyka JavaScript /  Funkce -->


    <p>Flexibilnost funkcí je jednou z nejsilnìjších stránek JavaScriptu. Podívejme se na monosti, které funkce nabízejí.
</p>

<h5>Co jsou funkce?</h5>
<p>Terminologií Javy bychom funkce JavaScriptu oznaèili jako metody.
Funkce jsou toti vdy bez vıjimky metodou nìjakého objektu.
I kdy definujete funkci "jen tak", jakoby globální, pøiøadí se jako metoda globálnímu objektu
(v prohlíeèích je to objekt <code>window</code>) a je v ní k dispozici promìnná <code>this</code>,
její hodnotou je reference na tento globální objekt.
</p>

<h5>Definování funkcí</h5>
<p>Funkce se definují pomocí pøíkazu <code>function</code>.
<pre><code class="js small_icon"><span class="k">function</span> <i>název</i> <span class="o">(</span> <i>parametry</i> <span class="o">)</span> <span class="o">{</span> <i>pøíkazy</i> <span class="o">}</span></code></pre>
Definice funkce obsahuje:
<ul> <li>název funkce
</li><li>libovolnı poèet parametrù dìlenı èárkami uzavøenı v kulatıch závorkách
</li><li>pøíkazy tvoøící tìlo funkce uzavøené ve sloenıch závorkách
</li><li>volitelnì v tìle funkce návrat hodnoty volající funkci, pomocí pøíkazu <code>return</code>
</li></ul>

Pøíklad definice funkce:
<pre><code class="js"
><span class="cml">// Zaøadí èíselnou hodnotu do nìkterého z intervalù urèenıch polem</span>
<span class="k">function</span> GetInterval<span class="o">(</span>iVal<span class="o">,</span> ai<span class="o">){</span>
	<span class="k">for</span><span class="o">(</span>var i<span class="o">=</span>0<span class="o">;</span> i <span class="o">&lt;</span> ai<span class="o">.</span>length<span class="o">;</span> i<span class="o">++)</span>
		<span class="k">if</span><span class="o">(</span>iVal <span class="o">&lt;</span> ai<span class="o">[</span>i<span class="o">])</span> <span class="k">return</span> i<span class="o">;</span>
	<span class="k">return</span> ai<span class="o">.</span>length<span class="o">;</span>
<span class="o">}</span> </code></pre>

Jak bylo zmínìno vıše, takto globálnì definovaná funkce se pøiøadí globálnímu objektu.
Také bylo øeèeno, e funkce je objekt, tedy promìnná. 
Takto definovaná funkce je tedy promìnná globálního objektu, v nìm je uloena funkce.
Zcela stejnı efekt tedy bude mít i druhá monost, jak definovat funkci:

<pre><code class="js"
><span class="cml">// Zaøadí èíselnou hodnotu do nìkterého z intervalù urèenıch polem</span>
<span class="k">var</span> GetInterval <span class="o">=</span> <span class="k">function</span><span class="o">(</span>iVal<span class="o">,</span> ai<span class="o">){</span>
	<span class="k">for</span><span class="o">(</span>var i<span class="o">=</span>0<span class="o">;</span> i <span class="o">&lt;</span> ai<span class="o">.</span>length<span class="o">;</span> i<span class="o">++)</span>
		<span class="k">if</span><span class="o">(</span>iVal <span class="o">&lt;</span> ai<span class="o">[</span>i<span class="o">])</span> <span class="k">return</span> i<span class="o">;</span>
	<span class="k">return</span> ai<span class="o">.</span>length<span class="o">;</span>
<span class="o">}</span> </code></pre>

A do tøetice: Jeliko funkce je objekt, má i svùj konstruktor <code>Function()</code>, kterı je mono pouít k vytvoøení funkce.
Tomuto konstruktoru se jako parametry pøedávají názvy formálních parametrù vytváøené funkce,
a jako poslední parametr se pøedává øetìzec s celım tìlem funkce:
<pre><code class="js"
><span class="cml">// Zaøadí èíselnou hodnotu do nìkterého z intervalù urèenıch polem</span>
<span class="k">var</span> GetInterval <span class="o">=</span> <span class="k">new</span> Function<span class="o">(</span><span class="s">"iVal"</span><span class="o">,</span> <span class="s">"ai"</span><span class="o">,</span>
<span class="s">"for(var i=0; i &lt; ai.length; i++)
   if(iVal &lt; ai[i]) return i;
 return ai.length;"</span><span class="o">);</span></code></pre>
Tato metoda je nejménì pohodlná, nicménì má svoje opodstatnìní:
Tímto zpùsobem lze vytvoøit funkci zcela dynamicky jako kterıkoliv jinı typ;
mùeme si tedy za bìhu sestavit tìlo funkce podle aktuální potøeby a tuto funkci vytvoøit.
Takovı postup se ovšem pro svou sloitost vyuívá jen vıjimeènì.
</p>

<h5>Volání funkcí</h5>
<p>Funkce se volají tak, e sestavíme libovolnı vıraz,
kterı odkazuje na promìnnou s funkcí nebo se vyhodnotí jako funkce,
a za nìj dáme kulaté závorky s libovolnım poètem parametrù.
V nejèastìjším pøípadì to tedy bude vypadat nìjak takto &ndash; globální voláni funkce:
<pre><code class="js"
><span class="cml">// Do kterého intervalu patøí 3.8?</span>
<span class="k">var</span> iInterval <span class="o">=</span> GetInterval<span class="o">(</span><span class="n">3.8</span><span class="o">,</span> <span class="o">[</span><span class="n">0</span><span class="o">,</span><span class="n">1</span><span class="o">,</span><span class="n">4</span><span class="o">,</span><span class="n">5</span><span class="o">]</span><span class="o">);</span></code></pre>

Mùeme volat také funkce objektù:
<pre><code class="js"
><span class="cml">// Najdeme lomitko</span>
<span class="k">var</span> iPosLomeno <span class="o">=</span> <span class="s">"img/fotka1.jpg"</span>.indexOf<span class="o">(</span><span class="s">"/"</span><span class="o">);</span></code></pre>

Ovšem mùeme se dopracovat i k takovéto kreaci:
<pre><code class="js"
><span class="k">var</span> sJmenovka = ((<span class="k">var</span> cClovek = <span class="k">function</span>(sJmeno, sTitul)
  { <span class="k">this</span>.sJmeno = sJmeno; <span class="k">this</span>.sTitul = sTitul; }
	).prototype.getJmenovka
  = <span class="k">new</span> Function(<span class="s">"return this.sTitul + ' ' + this.sJmeno;"</span>)
  ).<span class="f">call</span>(window.oIlona = <span class="k">new</span> cClovek(<span class="s">"Ilona"</span>, <span class="s">"Ing."</span>));</code></pre>

Zde jsme pouili hned nìkolik pokroèilıch konstrukcí JavaScriptu a vısledek odpovídá tomuto kódu:
<pre><code class="js"
><span class="cml">// Konstruktor tøídy cClovek</span>
<span class="k">function</span> cClovek(sJmeno, sTitul){
  <span class="k">this</span>.sJmeno = sJmeno; <span class="k">this</span>.sTitul = sTitul;
}
<span class="cml">// Definice funkce getTitul()</span>
cClovek.prototype.getJmenovka = <span class="k">function</span>(){
  <span class="k">return this</span>.sTitul + <span class="s">' '</span> + <span class="k">this</span>.sJmeno;
}
<span class="cml">// Vytvoøení objektu tøídy cClovek</span>
<span class="k">var</span> oIlona = <span class="k">new</span> cClovek(<span class="s">"Ilona"</span>, <span class="s">"Ing."</span>));
<span class="cml">// Získání jmenovky</span>
<span class="k">var</span> sJmenovka = oIlona.getJmenovka();
</code></pre>
Z pøíkladu je vidìt, e volání funkcí v JavaScriptu skoro nemá omezení.
V první komplikované verzi napøíklad voláme funkci hned po její definici,
kterou rovnou pøiøadíme promìnné, kterou ještì v tom samém vırazu pouijeme
jednak k definici metody této tøídy a pak ještì k instanciování objektu,
naèe tento objekt pøedáme té právì definované metodì. Zapeklité, e? :-)

</p><p>Bohuel teoretická krása dokonalosti JavaScriptu v realitì silnì naráí
na&nbsp;omezení implementacemi. <!-- Nejhorší --> Nejrozšíøenìjší
(a podlé mého názoru i lidovì øeèeno nejodfláknutìjší) prohlíeè souèasnosti,
Microsoft Internet Explorer, je notoricky známı velice svéráznım pojetím
JavaScriptu, které se bohuel nechová ani podle standardu EcmaScript,
ani podle dokumentace jeho vırobce.
Prohlíeèe Mozilla (napø. <a href="firefox.czilla.cz">Firefox</a>)
zase mají obèas tendenci na opravdu sloitıch konstrukcích "padat".
Tyto problémy se však verzi od verze rychle redukují.

</p><p>Funkce mají nìkolik dalších uiteènıch vlastností, jako tøeba
vlastnost <code>length</code>, metody <code>apply()</code> a <code>call()</code> (tu jsme pouili v pøíkladu).
Zájemci o podrobnosti opìt odkazuji na knihu <a href="#zdroj_javascript">JavaScript - kompletní prùvodce</a>.
Vlastnost <code>prototype</code> si pøedstavíme v následující èásti pojednávající o tøídách a objektech.

<!-- </p><p> -->
</p>


</div>
			</div>
			<div>
				<a name="k-a-2-4"></a>
				<h4>A.2.5. Tøídy a objekty</h4>
				<div><!-- Struènı popis jádra jazyka JavaScript / Tøídy  -->

<!-- konstruktory, metody, instanciace, definice tøíd, prototypy a dìdiènost, uvolòování pamìti  -->

<p>JavaScript je silnì objektovı jazyk. Prakticky je vystavìn na objektech.
Pøesto v nìm chybí nìkteré typické prvky objektovì orientovaného programování,
jako napøíklad skrıvání èlenskıch promìnnıch, a jiné jsou realizovatelné jen
obtínì, napøíklad dìdiènost.

</p><p>Na druhou stranu objektové principy JavaScriptu jsou vystavìny 
tak flexibilnì, e záleí prakticky jen na fantazii a dovednostech
programátora, co s JavaScriptem dokáe.
Jako pøíklad mùe slouit napø.
<a href="http://www.crockford.com/javascript/little.html">Little JavaScripter</a>,
implementace jazyka LISP v JavaScriptu,
od JavaScriptového nadšence s kontroverzními názory, <a href="http://www.crockford.com/">Douglase Crockforda</a>.
</p><p>V této èásti si pøedvedeme základní prvky práce se tøídami.
</p>

<h5>Konstruktory</h5>
<p>Objekt v JavaScriptu je pomìrnì volná datová struktura. Funguje prostì jako <i>hash</i>&nbsp;[heš]:
má svoje promìnné zvané vlastnosti, které v sobì ukládá pod urèitım názvem.
V podstatì se tedy jedná o asociativní pole promìnnıch.
Vlastnosti mùeme libovolnì pøidávat, zjišovat, mìnit a ubírat.
<!-- Nìkteré z tìchto promìnnıch mohou bıt funkce, a pak se jedná o metodu objektu. -->
</p><p>Takováto volná koncepce je pomìrnì chaotická.
Abychom si usnadnili tvorbu více objektù podobné struktury, je potøeba vytvoøit nìjakou šablonu,
podle které se budou objekty s nìjakou potøebnou formou vytváøet.
Touto šablonou je konstruktor.
</p><p>Konstruktor je funkce. Kadá funkce mùe poslouit jako <i>konstruktor</i>.
K vytvoøení objektu tímto konstruktorem staèí pouít klíèové slovo <code>new</code>:
</p>
<pre><code class="js"
><span class="cml">// Vrátí souèet dvou argumentù</span>
<span class="k">function</span> Secti(iA, iB){ <span class="k">return</span> iA + iB; }
<span class="cml">// Pouije funkci Secti jako konstruktor objektu</span>
<span class="k">var</span> objekt = <span class="k">new</span> Secti(1, 2);</code></pre>

<p>Pøedchozí ukázka samozøejmì nedává pøíliš smysl. Jako konstruktor je pouita funkce,
která evidentnì nebyla k takovému úèelu zamıšlena ani navrena.

</p><p>V této práci pouíváme jako nápovìdu, e se jedná o funkci tvoøenou jako konstruktor,
 oznaèení pøejaté z C++ &ndash; pøed název pøidáme malé&nbsp;"c" (jako <i>class</i>).
Podle kódu se konstruktor pozná tak, e nastavuje nìjaké hodnoty pomocí slova <code>this</code>,
obvykle tyto hodnoty pøebírá z argumentù, a nevrací ádnou hodnotu.
</p>

<pre><code class="js"
><span class="cml">// Konstruktor tøídy cClovek</span>
<span class="k">function</span> cClovek(sJmeno, iRokNarozeni){
  <span class="k">this</span>.sJmeno = sJmeno;
  <span class="k">this</span>.iRokNarozeni = iRokNarozeni;
  <span class="k">this</span>.sTitul = <span class="s">""</span>;
}</code></pre>

<p>Dále v kódu mùeme také najít pøiøazení metod této tøídì:
</p>

<pre><code class="js"
><span class="cml">// cClovek::SetTitul(sTitul)</span>
cClovek.prototype.SetTitul = <span class="k">function</span> (sTitul){
  <span class="k">this</span>.sTitul = sTitul;
}</code></pre>

<p>Øekli jsme si, e metody objektu jsou funkce uloené jako jeho vlastnosti.
Co tedy znamená <code class="jsl">cClovek.prototype</code> ?
Pøi definici tøídy nemáme k dispozici ádnı objekt, kterému bychom funkci pøiøadili.
Proto má kadá funkce (potenciální konstruktor) vlastnost prototype,
ze které novì vytváøenı objekt pøebírá všechny hodnoty zvláštním zpùsobem, kterı si popíšeme dále.

</p><p>Vytváøení objektu definované tøídy se provádí pouitím klíèového slova <code>new</code>:
</p>

<pre><code class="js"
><span class="cml">// Vytvoøí objekt tøídy cClovek</span>
<span class="k">var</span> oIlona = <span class="k">new</span> cClovek(<span class="s">"Ilona"</span>, <span class="n">1980</span>);</code></pre>
Od teï máme v promìnné oIlona vytvoøenı objekt tøídy cClovek a mùeme k nìmu tak pøistupovat.
<pre><code class="js"
><span class="cml">// Nastaví clovìku titul</span>
oIlona.SetTitul(<span class="s">"Ing."</span>);</code></pre>

<h5>Metody</h5>
<p>Metody jsme si víceménì pøedstavili u vıše. Zde akorát vysvìtlím vlastnost <code class="jsl"><i>konstruktor</i>.prototype</code>.
Metoda je vlastnost objektu, jeho hodnotou je funkce.
Pøiøazovat kadému jednotlivému objektu tuto funkci v konstruktoru je moné:
</p>

<pre><code class="js"
><span class="cml">// Konstruktor tøídy cClovek</span>
<span class="k">function</span> cClovek(sJmeno, iRokNarozeni){
  <span class="k">this</span>.sJmeno = sJmeno;
  <span class="k">this</span>.iRokNarozeni = iRokNarozeni;
  <span class="k">this</span>.sTitul = <span class="s">""</span>;
  <span class="k">this</span>.SetTitul = <span class="¨k">function</span>(sTitul){ <span class="k">this</span>.sTitul = sTitul; };
}</code></pre>

<p>Tento postup by ovšem vedl k tomu, e pro kadı vytváøenı objekt by se vytvoøila nová funkce.
To je znaènì neelegantní, pro interpreter JavaScriptu neefektivní
a pøi vìtším poètu malıch objektù s mnoha metodami by to bylo znaèné plıtvání zdroji.
Mohli bychom tedy vytvoøit funkci a tu pak pøiøazovat v konstruktoru:
</p>

<pre><code class="js"
><span class="cml">// Globální promìnná SetTitul obsahující funkci </span>
<span class="k">function</span> SetTitul(sTitul){ <span class="k">this</span>.sTitul = sTitul; };

<span class="cml">// Konstruktor tøídy cClovek</span>
<span class="k">function</span> cClovek(sJmeno, iRokNarozeni){
  <span class="k">this</span>.sJmeno = sJmeno;
  <span class="k">this</span>.iRokNarozeni = iRokNarozeni;
  <span class="k">this</span>.sTitul = <span class="s">""</span>;
  <span class="k">this</span>.SetTitul = SetTitul;
}</code></pre>

<p>Tento postup by èásteènì zmenšil neefektivitu a plıtvání pamìtí.
Tento zpùsob je však z hlediska kódování a podle principù OOP ještì horší,
protoe odtrhává funkci, která se tıká jenom jedné tøídy, a vkládá ji do globálního jmenného prostoru.
Navíc se takto stále kadému jednotlivému objektu pøiøazuje vlastnost s hodnotou, co není tøeba.
</p>

<p>V návrhu JavaScriptu je toti pro tento úèel u kadého konstruktoru k dispozici vlastnost <code>prototype</code>.
Ta má na starosti jednu zvláštní funkci: Pokud se pokusíme u objektu nìjaké tøídy èíst vlastnost, kterou
nemá nastavenou, interpreter JavaScriptu se ještì podívá objektu na vlastnost <code>constructor</code>,
ve kterém je uloena funkce, která byla pouita k vytvoøení objektu, a u tohoto konstruktoru se podívá 
do vlastnosti <code>prototype</code>, jestli v ní není vlastnost stejného názvu, jakou se mìl pokusit èíst
v pùvodním objektu. Pokud ji najde, vrátí do vırazu její hodnotu.
</p>

<pre><code class="js"
><span class="cml">// Konstruktor tøídy cClovek</span>
<span class="k">function</span> cClovek(sJmeno, iRokNarozeni){
  <span class="k">this</span>.sJmeno = sJmeno;
  <span class="k">this</span>.iRokNarozeni = iRokNarozeni;
}
<span class="cml">// cClovek::sDruh</span>
cClovek.prototype.sDruh = <span class="s">"homo sapiens"</span>;
<span class="k">var</span> oKopcem = <span class="k">new</span> cClovek();
<span class="f">alert</span>(oKopcem.sDruh); <span class="cml">// Zobrazí 'homo sapiens'</span>
</code></pre>

<p>Ve ètení vlastnosti <code class="jsl"><span class="f">alert</span>(oKopcem.sDruh);</code>
se vıše popsanım zpùsobem najde a vrátí hodnota z <code>cClovek.prototype.sDruh</code>.
Pokud se pokusíme objektu hodnotu s názvem <code>sDruh</code> zmìnit, oproti bìnému chování se nic nemìní -
nastavíme tak hodnotu konkrétní instanci objektu a hodnota <code>cClovek.prototype.sDruh</code> zùstává netknutá.
</p>

<pre><code class="js"
>oKopcem.sDruh = <span class="s">"homo habilis"</span>;
<span class="f">alert</span>(cClovek.prototype.sDruh); <span class="cml">// Zobrazí 'homo sapiens'</span>
</code></pre>


<h5>Dìdiènost</h5>
<p>Pokud chceme nìjakı jazyk oznaèit za objektovì orientovanı, mìl by nepochybnì zvládat dìdiènost.
JavaScript se vypoøádává s dìdìním se sobì vlastní jednoduchostí a pouívá monosti døíve popsané.
</p><p>Pøi realizaci dìdìní se vychází z pøedpokladu, e pro definici tøíd se pouívá vlastnost
konstruktoru <code>prototype</code>. Pokud je tomu tak, mùeme toho vyuít k odvození.
</p><p>Tøída, která má bıt odvozena od jiné, jednoduše dosadí do svojí vlastnosti <code>prototype</code>
instanci této vzorové tøídy. Tím se vytvoøí kompletní sada vlastností, tedy i metod,
a vloí se do vlastnosti <code>prototype</code>.
</p>

<pre><code class="js"
><span class="k">function</span> cClovekStudent(sJmeno, iRokNarozeni){
  <span class="k">this</span>.sJmeno = sJmeno;
  <span class="k">this</span>.iRokNarozeni = iRokNarozeni;
}
cClovekStudent.prototype = <span class="k">new</span> cClovek(<span class="s">""</span>, <span class="s">null</span>);
</code></pre>

<p>To však ještì nestaèí. Zaprvé je evidentní, e takto se ztratila monost
inicializace argumenty konstuktoru nadøazené tøídy a musíme psát kód znovu.
Zadruhé je zde skryt jeden chyták, kterı by nám mohl dìlat záhadné problémy pozdìji:
Inicializací 
<code class="jsl"><span class="k">new</span> cClovek(<span class="s">""</span>, <span class="s">null</span>);</code>
vznikne objekt, kterı bude mít ve svojí vlastnosti <code>constructor</code> funkci, kterou byl vytvoøen,
tedy <code>cClovek</code>. Jeliko pøi instanciaci objekty pro inicializaci svojí hodnoty <code>constructor</code>
pouívají právì hodnotu z prototypu svého konstruktoru, která za bìnıch podmínek implicitnì nastavena
na funkci samotnou (tedy platí <code class="jsl"><i>funkce</i>.prototype.constructor = <i>funkce</i></code>),
potom pøi vytváøení objektu odvozené tøídy by i tento objekt pøejal do vlastnosti <code>constructor</code> konstruktor
nadøazené tøídy.

</p><p>Oba tyto problémy se dají jednoduše vyøešit:
</p>

<pre><code class="js"
><span class="k">function</span> cClovekStudent(sJmeno, iRokNarozeni){
  <span class="cml">// Voláme konstruktor nadøazené tøídy - opìtovné pouití kódu</span>
  <span class="k">this</span>.prototype.constructor.call(this, sJmeno, iRokNarozeni);
  <span class="cml">// Nastavíme konstruktor této tøídy jak má bıt - na tuto funkci:</span>
  <span class="k">this</span>.prototype.constructor = <span class="k">this</span>;
}
cClovekStudent.prototype = <span class="k">new</span> cClovek(<span class="s">""</span>, <span class="s">null</span>);

<span class="cml">// Nyní ji mùeme </span>
var oOndra = <span class="k">new</span> cClovekStudent(<span class="s">"Ondra"</span>, <span class="s">1983</span>);
</code></pre>


<h5>Uvolòování pamìti</h5>
<p>O uvolòování pamìti se v JavaScriptu témìø nemusíme starat.
JavaScript toti obsahuje <i>garbage collector</i> (sbìraè odpadu) pracující na principu hlídání (poèítání) referencí.
Vıjimkou, kterou bychom mìli mít na pamìti zejména v programech,
které mají bìet dlouhou dobu nebo dokonce nepøetritì,
je cyklická reference.
</p><p>Cyklická reference je programátorùm pracujícím v prostøedích s automatickım uvolòováním pamìti
na principu poèítání odkazù
známı problém. Jedná se o situaci, kdy vytvoøíme v objektech vzájemné odkazy:
</p>

<pre><code class="js"
><span class="cml">// Nejjednodušší cyklická reference</span>
<span class="k">var</span> oA = { b: <span class="l">null</span> };
<span class="k">var</span> oB = { a: oA };
oA.b = oB;

<span class="cml">// Zbavíme se monosti odkázat se na objekty</span>
oA = <span class="l">null</span>;
oB = <span class="l">null</span>;
</code></pre>

<p>Ve vısledku <code>oA.b</code> odkazuje na <code>oB</code> a <code>oB.a</code> na <code>oA</code>, ale my u ani na jeden nemáme reference.
(Poznamenejme, e objekty se v JavaScriptu ukládají referencí, tedy nastavením reference na <code>null</code> objekt nezanikne.)
Objekty tedy existují, ale my se na nì nemáme jak odvolat.
Garbage collector ale pracuje tak, e objekt uvolní tehdy, kdy na nìj nejsou v celém programu
ádné odkazy. Zde však na oba objekty odkazy jsou - v druhém objektu.

</p><p>Naštìstí takto jednoduchı pøípad vìtšina implementací JavaScriptu dokáe rozpoznat a objekty zlikvidovat.
Bohuel cyklické reference obvykle vznikají v mnohem sloitìjších datovıch strukturách a pøijít na to je pomìrnì sloité.
Proto bychom mìli u struktur, u kterıch si nejsme úplnì jisti, zda cyklické reference nemohou vzniknout,
vytipovat "mùstky", které musíme zboøit, aby mìl garbage collector monost tyto objekty uvolnit.
Zboøení provedeme nastavením promìnné s referencí na <code>null</code>:
</p>

<pre><code class="js"
><span class="cml">// Nejjednodušší cyklická reference</span>
<span class="k">var</span> oA = { b: <span class="l">null</span> };
<span class="k">var</span> oB = { a: oA };
oA.b = oB;

<span class="cml">// Zbavíme se referencí (zboøíme mùstky)</span>
oA.b = <span class="l">null</span>;
oB.a = <span class="l">null</span>;
</code></pre>

<p>V JavaScriptu ještì máme uiteènı operátor <code>delete</code>, kterı narozdíl od
nastavení reference na jinou hodnotu (tøeba null) objekt skuteènì odstraní.
</p>

<pre><code class="js"
><span class="cml">// Nejjednodušší cyklická reference</span>
<span class="k">var</span> oA = { b: <span class="l">null</span> };
<span class="k">var</span> oB = { a: oA };
oA.b = oB;
...
<span class="cml">// Smaeme objekty</span>
<span class="k">delete</span> oA;
<span class="k">delete</span> oB;
</code></pre>

<p>Pøi pouití operátoru <code>delete</code> by mìl interpreter JavaScriptu provést s objektem krátkı proces
a jednoduše ho odstranit, navíc veškeré reference na nìj nastavit na null.

</p><p>Novìjší implementace JavaScriptu místo poèítání referencí rekurzivnì procházejí celı jmennı prostor
prostøedí a oznaèují jednotlivé existující objekty, ke kterım najdou cestu.
Ty, které na konci procesu zùstanou neoznaèené, jsou nedosaitelné, tedy zbyteèné a je moné je uvolnit.
Bohuel dnes stále ještì nejrozšíøenìjší prohlíeè Internet Explorer 6 je vystavìn na
technologii COM, která rovnì pouívá k uvolòování pamìti poèítání referencí.
Tím se nemùe tohoto principu vzdát a je kvùli nìmu potøeba nadále cyklickım referencím pøedcházet.
</p>
</div>
			</div>
			<div>
				<a name="k-a-2-5"></a>
				<h4>A.2.6. Regulární vırazy</h4>
				<div><!-- Struènı popis jádra jazyka JavaScript / Regulární vırazy -->


    <p>Pøímo ve specifikaci JavaScriptu je zahrnuta podpora regulárních vırazù.
Regulární vıraz je øetìzec, kterı popisuje šablonu znakù. Pomocí této šablony lze
vyhledávat vıskyty øetìzcù odpovídajících této šablonì nebo testovat shodu øetìzce s šablonou.
</p><p>Regulární vıraz JavaScriptu je objekt tøídy <code>RegExp</code>, kterı vznikne buï
jejím konstruktorem nebo zápisem literálu (napø. /ahoj|nazdar|dobrı den/i	).
</p><p>Vyhledávání pozice, vyhledávání podøetìzcù a nahrazování se provádí voláním pøíslušné metody tøídy String:
<pre><code class="js"
><span class="k">var</span> s = <span class="s">"Ahoj lidi, dobrı den vespolek"</span>;
<span class="cml">// Vrací 0 - najde Ahoj na zaèátku</span>
s.search(<span class="re">/ahoj|nazdar|dobrı den/i</span>);
<span class="cml">// Vrací ["Ahoj", "dobrı den"]</span>
s.match(<span class="re">/ahoj|nazdar|dobrı den/gi</span>);
<span class="cml">// Vrací "tì pic, tì pic vespolek"</span>
s.replace(<span class="re">/ahoj|nazdar|dobrı den/gi</span>, <span class="s">"tì pic"</span>);
</code></pre>
Další moností je pouít pøímo metody objektu regulárního vırazu - <code>exec()</code> a <code>test()</code>.
</p><p>Zájemci o podrobnosti nech si laskavì pøeètou kapitolu 10 v knize
<a href="#zdroj_javascript">JavaScript - kompletní prùvodce</a>.
Pokud by nìkdo chtìl znát regulární vırazy opravdu dokonale, mùe svou pozornost zamìøit k jazyku Perl,
ve kterém se r.v. objevily poprvé a jejich implementace je v nìm jednoznaènì nejdále.
</p>


</div>
			</div>
			<div>
				<a name="k-a-2-6"></a>
				<h4>A.2.7. Vestavìné objekty a metody</h4>
				<div><!-- Struènı popis jádra jazyka JavaScript / Vestavìné objekty a metody -->


<p>Jádro JavaScriptu obsahuje nìkolik tøíd, které buï zajišují potøebnou funkènost jazyka,
nebo usnadòují nejbìnìjší operace, jako napø. práci s èasovımi údaji.
</p>

<h5>Object</h5>
<p>Tøída objekt je bázovou tøídou pro veškeré ostatní tøídy,
tzn. jsou od ní pøímo èi nepøímo všechny tøídy odvozeny.
Se všemi objekty je tedy mono pracovat pomocí metod tøídy Object.
</p>

<h6>Object.constructor</h6>
<p>Kadı objekt v prostøedí JavaScriptu má vlastnost <code>constructor</code>.
Podle této vlastnosti je moné urèit, s jakım vlastnì objektem máme tu èest.
Pokud napøíklad budeme chtít zkontrolovat, jestli pracujeme s objektem <code>Date</code>,
provedeme to takto:
<pre><code class="js"
><span class="cml">// Funkce kontroluje, jestli v parametru dostává objekt Date,
// jinak by mohlo dojít k bìhové chybì.</span>
<span class="k">function</span> UrciNejblizsiVikend(oDatum){
  <span class="k">if</span>(!oDatum || <span class="s">"object"</span> != <span class="k">typeof</span> oDatum 
      || <span class="f">Date</span> != oDatum.constructor)
    <span class="k">return null</span>;
  <span class="cml">// ...</span>
}</code></pre>
</p>

<h6>Object.toString()</h6>
<p>Z kadého objektu je mono získat øetìzcovou reprezentaci. Slouí k tomu metoda <code>toString()</code>.
JavaScript tuto metodu volá automaticky, kdy potøebuje pøevést objekt na øetìzec, napøíklad
pokud zadáte objekt jako parametr metodì <code>document.write()</code>.
Pro tøídu Objekt je tato metoda definována tak, e vrací øetìzec "[object <i>prototype.constructor</i>]",
napø. "[object Window]"
</p><p>Pøetíením této metody v odvozené tøídì je mono ovlivnit implicitní textovou reprezentaci objektù této tøídy.
</p>

<h6>Object.toLocaleString()</h6>
<p>Tato metoda má vracet lokalizovanou verzi øetìzce, kterı vrací <code>toString()</code>.
Z vestavìnıch tøíd tuto metodu pøetìují <code>Array</code>, <code>Date</code> a <code>Number</code>.
</p>

<h6>Object.valueOf()</h6>
<p>Tato metoda by mìla vrátit nìjakou primitivní metodu reprezentující objekt, nejlépe èíslo.
To dává smysl napøíklad u vestavìnıch tøíd obalujících primitivní typy - napø. Number nebo Boolean.
Jejich pøetíená verze této metody vrací jejich hodnotu, take je tyto objekty mono pouít stejnì
jako primitivní hodnoty.
</p>

<h6>Object.hasOwnProperty(sPropertyName)</h6>
<p>Vrací true, pokud objekt lokálnì definuje nedìdìnou vlastnost s názvem zadanım v argumentu, jinak false.
</p>

<h6>Object.propertyIsEnumerable(sPropertyName)</h6>
<p>Vrací true, pokud má objekt definovanou vlastnost s názvem zadanım v argumentu
a pokud bude tato vlastnost procházena vıètem <code>for(... in ...)</code>, jinak false.
</p>

<h6>Object.isPrototypeOf(oObject)</h6>
<p>Vrací true, pokud je objekt prototypovım objektem objektu zadaného v argumentu, jinak false.
</p>


<h5>String</h5>
<p>Asi nejdùleitìjší z vestavìnıch tøíd. Veškeré textové øetìzce v JavaScriptu jsou objekty tøídy String.
Tøída má pomìrnì hodnì metod, nebudeme se zde zabıvat všemi. Nastiòme si však charakteristické prvky.
</p><p>Øetìzce nejsou pole znakù. Aèkoliv by mohly bıt (internì je znak uloen jako dva bajty), návrhovì èistší
je øešení absolutního uzavøení dat øetìzce do objektu. K jednotlivım znakùm pøistupujeme metodou <code>charAt(<i>iIndex</i>)</code>.
</p><p>Øetìzce jsou nemìnné. Podobnì jako v Javì, jsou vytvoøené objekty na jedno pouití, a jakákoliv modifikace je nemoná.
Jakákoliv operace pomocí metod vdy vede k vytvoøení nového objektu.
</p><p>Øetìzce se porovnávají hodnotou. Na rozdíl od C++, kde je tøeba øetìzce (které jsou vlastnì polem bajtù)
porovnávat nìjakou funkcí, v JavaScriptu se pøedpokládá, e pøi porovnání dvou objektù tøídy String nechcete porovnat,
zda se jedná o tentı objekt, ale zda obsahuje identickou sekvenci znakù.
</p><p>Spojování øetìzcù se provádí operátorem plus. To s sebou nese riziko vzniku chyb:
Pokud v jednom vırazu budete chtít zároveò spojovat øetìzce i sèítat, bez závorek se souètu nedoèkáte:
</p>
<pre><code class="js block"
><span class="k">var</span> iPlat = <span class="n">12</span>*<span class="n">60000</span>, iUplatky = <span class="n">3800000</span>, iVynosZPerlovky = <span class="n">1200000</span>;
<span class="cml">// Zobrazí vıdìlek 72000038000001200000</span>
<span class="f">alert</span>(<span class="s">"Politik S.G. si za poslední rok vydìlal "</span>
   + iPlat + iUplatky + iVynosZPerlovky + <span class="s">" Kè."</span>);
</code></pre>
<p>
Sèítání má toti asociativitu zleva doprava, pøi sèítání prvního øetìzce s èíslem dojde tedy k pøetypování
èísla na øetìzec a vznikne opìt øetìzec, a tak to jde dál. Pokud budou èísla vpøedu, nic se nedìje:
<!-- Vhodnìjší by bylo pouít nìkterı z volnıch znakù, napø. "^", nebo "pøetíit" jinı operátor, tøeba "~". -->
</p>

<pre><code class="js block"
><span class="k">var</span> iPlat = <span class="n">12</span>*<span class="n">60000</span>, iUplatky = <span class="n">3800000</span>, iVynosZPerlovky = <span class="n">1200000</span>;
<span class="cml">// Zobrazí vıdìlek 5 720 000</span>
<span class="f">alert</span>(iPlat + iUplatky + iVynosZPerlovky D.
  + <span class="s">" Kè je vıdìlek politika S.G za poslední rok."</span>);
</code></pre>

<h5>Array</h5>
<p>Tøída Array zajišuje funkènost polí. Pole jsou pouívána podobnì jako v Javì.
Navíc ale, protoe jsou pole také objekty, je moné pøiøadit hodnoty i vlastnostem tohoto objektu.
Vzniká tak zdání asociativního pole, známého tøeba z PHP:
<pre><code class="js"
><span class="cml">// Vytvoøíme pole</span>
<span class="k">var</span> aPole = <span class="k">new</span> <span class="f">Array</span>();
<span class="cml">// Prvku pole na indexu 5 pøiøadíme hodnotu "pìt" </span>
aPole[<span class="n">5</span>] = <span class="s">"pìt"</span>;
<span class="cml">// Objektu aPole nastavíme vlastnost pìt na hodnotu 5</span>
aPole[<span class="s">"pìt"</span>] = <span class="n">5</span>;
</code></pre>
</p>

<h6>Array.length</h6>
<p>Vlastnost length je jen ke ètení a udává èíslo o jedna vyšší ne nejvyšší obsazenı index v poli.
Pokud tedy budeme mít prázdné pole, kterému na index [10] pøiøadíme hodnotu, <code>length</code> bude 11.
Indexy pole mohou nabıvat hodnot od 0 do 2<sup>32</sup>-1.
</p>

<a name="k-a-2-6-vicepole"></a>
<h6>Pøístup k prvkùm pole - operátor <code>[]</code></h6>
<p>K prvkùm pole se pøistupuje pomocí operátoru <code>[<i>iIndex</i>]</code>.
Tento operátor je moné pouít i pro pøístup k vlastnostem jakéhokoliv objektu.
To platí i u polí. To je tøeba mít na pamìti, aby nedošlo k chybì napø. pøi pokusu o zápis
do existující vlastnosti, u polí napø. <code>length</code>. Pro dosaení funkce
asociativních polí proto doporuèujeme pouívat objekty tøídy Object.
</p><p>Vícerozmìrná pole v JavaScriptu nejsou. Prvek pole však mùe bıt opìt pole.
Pro pøístup pak vyuijeme fakt, e vıraz <code><i>pole</i>[<i>index</i>]</code> je opìt pole,
mùeme na nìj opìt aplikovat operátor <code>[]</code>:
<pre><code class="js"
><span class="cml">// Vytvoøíme "vícerozmìrné" pole</span>
<span class="k">var</span> aaxPole<span class="o"> = </span><span class="o">[[</span><span class="n">1</span><span class="o">,</span><span class="n">2</span><span class="o">,</span><span class="n">3</span><span class="o">]</span><span class="o">,</span> <span class="o">[</span><span class="n">4</span><span class="o">,</span><span class="n">5</span><span class="o">]</span><span class="o">,</span> <span class="o">[</span><span class="n">6</span><span class="o">,</span><span class="n">7</span><span class="o">,</span><span class="s">"ahoj"</span><span class="o">]]</span><span class="o">;</span>
<span class="k">var</span> xPrvek_2_1  <span class="o"> = </span>aaxPole<span class="o">[</span><span class="n">2</span><span class="o">]</span><span class="o">[</span><span class="n">1</span><span class="o">]</span><span class="o">;</span>   <span class="cml">// obsahuje 4</span>
<span class="k">var</span> xPrvek_2_50 <span class="o"> = </span>aaxPole<span class="o">[</span><span class="n">2</span><span class="o">]</span><span class="o">[</span><span class="n">50</span><span class="o">]</span><span class="o">;</span>  <span class="cml">// obsahuje undefined</span>
<span class="k">var</span> xPrvek_50_50<span class="o"> = </span>aaxPole<span class="o">[</span><span class="n">50</span><span class="o">]</span><span class="o">[</span><span class="n">50</span><span class="o">]</span><span class="o">;</span> <span class="cml">// vznikne vıjimka</span>
</code></pre>
V posledním pøíkazu vznikne vıjimka, protoe
<code class="jsl">aaxPole<span class="o">[</span><span class="n">50</span><span class="o">]</span></code>
se vyhodnotí jako <code>undefined</code>, a následné pouití operátoru <code>[]</code> je tedy chybné.
</p>
<img class="alone border" alt="Vıjimka vyvolaná pouitím operátoru [] na hodnotu undefined" src="img/priklady/p1_vicepole.gif" />

<p>Pøíklad najdete v souboru <a href="priklady/p-a-2-6-vicepole.html">p-a-2-6-vicepole.html</a>.</p>


<a name="k-a-2-6-obalky"></a>
<h5>Obálky primitivních typù</h5>
<p>Podobnì jako v Javì i v JavaScriptu mají primitivní typy kadı svou tøídu:</p>
<table>
<tr><th>primitivní typ</th> <th>obálka</th></tr>
<tr><td>string</td> <td>String</td></tr>
<tr><td>number</td> <td>Number</td></tr>
<tr><td>boolean</td> <td>Boolean</td></tr>
</table>
<p>V pøípadì potøeby JavaScript pøemìní primitivní hodnotu na objekt pøíslušné tøídy a nadále pracuje s ním.
To umoòuje zápisy jako:
</p>
<pre><code class="js"><span class="s">"Ahoj lidi"</span><span class="o">.</span><span class="f">substring</span><span class="o">(</span><span class="n">0</span><span class="o">,</span><span class="n">4</span><span class="o">);</span></code></pre>
<p>Jeliko tato konverze je transparentní a nehraje prakticky ádnou roli,
pro zjednodušení budeme pokládat primitivní hodnoty a objekty pøíslušnıch typù za toté.
</p>

</div>
			</div>
		</div>
		
		<div>
			<a name="k-a-3"></a>
			<h3>A.3. JavaScript ve webovıch prohlíeèích</h3>
			<!-- JavaScript ve webovıch prohlíeèích /  -->

<p>JavaScript má pùvod ve webovıch prohlíeèích. Jak jsme psali <a href="#k-a-1-2-hist">vıše</a>,
poprvé se objevil v prohlíeèi <a href="http://wp.netscape.com/newsref/pr/newsrelease82.html">Netscape Navigator 2.0</a>
a jeho tvùrcem je Brendan Eich. Oblast prohlíeèù je dodnes tìištìm vıvoje JavaScriptu
a v prohlíeèích je zároveò nejvíce vyuíván. Pøedstavíme si zbìnì, jak v nich pracuje.
</p>
			
			<div>
				<a name="k-a-3-1"></a>
				<h4>A.3.1. Objekt <code>window</code></h4>
				<div><!-- JavaScript ve webovıch prohlíeèích / Objekt window -->

<p>JavaScript musí mít nìjakı koøenovı objekt, ve kterém jsou ve stromové struktuøe všechny ostatní, neboli globální objekt.
V prohlíeèích tuto úlohu hraje objekt <code>window</code>, kterı zároveò pøedstavuje objekt okna prohlíeèe.
Ve svojí dvojroli tedy musí implementovat dvì rozhraní: Jednak globálního objektu a jednak okna prohlíeèe.
</p>

<a name="k-a-3-1-window_global"></a>
<h5>Objekt <code>window</code> jako globální objekt</h5>
<p>Z hlediska jádra JavaScriptu nás zajímají ty vlastnosti objektu <code>window</code>,
které implementuje pro potøeby jádra JavaScriptu. V objektu window tedy najdeme
hodnoty jako null, undefined, NaN, funkce String, Array, Date, parseUrl a podobnì.
Pøi vıètu vlastností sice vlastnosti globálního objektu vìtšina implementací skrıvá,
ovšem pøi pøímém dotazu na nì je nezapøe:
<pre><code class="js small_icon"
><span class="f">alert</span>(window.Array); <span class="cml">// Vypíše "function Array { [native code] }"</span></code></pre>
</p>

<p>Pøíklad najdete v souboru <a href="priklady/p-a-3-1-window_global.html">p-a-3-1-window_global.html</a></p>


<h5>Objekt <code>window</code> jako objekt okna prohlíeèe</h5>
<p>Z hlediska ovládání klienta (prohlíeèe) nás zajímají zejména následují vlastnosti:
</p>

<h6>Vlastnost <code>navigator</code></h6>
<p>Objekt <code>window.navigator</code> obsahuje informace o prohlíeèi -
jeho název (<code>appName</code>), verzi (<code>appVersion</code>),
kódové jméno (<code>appCodeName</code>), platformu (<code>platform</code>)
a nìkolik dalších informací ve vlastnosti <code>userAgent</code>.
</p>

<h6>Vlastnost <code>document</code></h6>
<p>Objekt <code>window.document</code> implementuje rozhraní <code>HTMLDocument</code>.
Nese údaje o dokumentu a zároveò pøedstavuje koøenovı uzel stromu dokumentu.
Objektem <code>document</code> se budeme zabıvat <a href="#k-a-3-2">dále</a>.
</p>

<h6>Vlastnost <code>screen</code></h6>
<p>Objekt <code>window.screen</code> poskytuje informace o dostupném prostoru obrazovky
prostøednictvím tìchto vlastností:
<ul> <li><code>width</code>, <code>height</code> - šíøka a vıška plochy, do které se
umisují okna prohlíeèe v maximalizované velikosti.
</li><li><code>availWidth</code>, <code>availHeight</code> - šíøka a vıška plochy obrazovky
neomezená grafickımi prvky systému jako hlavní panel apod. V podstatì rozlišení monitoru.
</li><li><code>colorDepth</code> - barevná hloubka udaná v bitech na pixel. Dnes obvykle 24.
</li></ul>
</p>

<h6><code>alert()</code>, <code>confirm()</code>, <code>prompt()</code></h6>
<p>Nejjednodušší metoda, jak uivateli nìco sdìlit nebo nìco zjistit.
Povaujeme ji zároveò za nejnevkusnìjší, proto ji pouíváme jen pøi ladìní nebo v ukázkách.
</p>

<h6><code>open()</code></h6>
<p>Pomocí <code>window.open()</code> se dá otevøít nové okno.
Je to spjato s jistımi problémy s nekompatibilitou prohlíeèù,
ale zejména s tím, e mnoho uivatelù má otevírání oken JavaScriptem zakázáno.
Je to však jediná monost, jak nové okno programovì otevøít.
</p>

<h6><code>setTimeout()</code>, <code>setInterval()</code></h6>
<p>Metody <code>setTimeout()</code> a <code>setInterval()</code> jsou jedinım 
rozumnım prostøedkem v prohlíeèích, jak programovì v budoucnosti vyvolat událost
v urèitém èase. Pouití <code>setInterval()</code> s sebou nese riziko, e obsluha
události potrvá déle ne interval a ještì bìhem obsluhy se vyvolá událost znova.
Proto v této práci preferujeme opakované volání <code>setTimeout()</code>.
</p>

<h6>Je okno vhodnı globální objekt?</h6>
<p>Na závìr sekce o objektu window bych rád podotkl, e tuto funkèní schizofrenii objektu window
povauji za nešastnou a daleko sympatiètìjší by mi byl oddìlenı globální objekt, teprve jeho
vlastností by bylo (jediné) okno aktuální instance. Dalo by se tak pøedejít nìkterım nejednoznaènostem
pøi volání metod jako <code>open()</code> a <code>close()</code>.</p>


</div>
			</div>
			<div>
				<a name="k-a-3-2"></a>
				<h4>A.3.2. Objekt <code>window.document</code></h4>
				<div><!-- JavaScript ve webovıch prohlíeèích / Objekt Document -->

<p>Objekt <code>window.document</code> má opìt dvojí roli.
Jednak vystupuje jako koøenovı element stromu dokumentu (DOM <code>DocumentElement</code>)
a jednak umoòuje obsluhu nìkterıch funkcí prohlíeèe.
</p>

<h5>Objekt <code>window.document</code> ovládající prohlíeè</h5>

<h6><code>write()</code> a <code>writeln()</code></h6>
<p>Metoda document.write() umoòuje bìhem fáze zpracovávání dokumentu dynamicky vypisovat obsah.
Po naètení a zpracování dokumentu tato metoda zpùsobí implicitní volání metody <code>document.open()</code>,
která vymae veškerı pøedchozí obsah.
</p><p>Metoda <code>document.writeln()</code> se chová stejnì, akorát za vámi dodanı øetìzec pøidá znak nového øádku.
</p>

<h6>cookie</h6>
<p>Vlastnost <code>document.cookie</code> umoòuje skriptùm ukládat si v klientské aplikaci
tzv. cookies, tedy krátké øetìzce. Bez pøipojení k internetu je to jediná monost
bìnıch skriptù, jak uloit informaci tak, aby mìla aspoò nìjakou šanci zùstat uloená
do pøíštího spuštìní skriptu.
</p><p>Tuto vlastnost vyuívá hra Miner k uloení a nahrání hry.
</p><p>Podrobnìji se cookies budeme zabıvat v sekci <a href="#k-a-3-5">Provázanost JavaScriptu s Cookies</a>.
</p>

<h6>Rùzné kolekce objektù ve stránce podle druhu</h6>
<p>V objektu <code>document</code> je také nìkolik kolekcí (polí), které obsahují
reference na objekty urèitého typu.
<ul> <li><code>anchors[]</code> - kotvy v dokumentu (<code class="htmll">&lt;a name="<i>jméno</i>"&gt;...&lt;/a&gt;</code>)
</li><li><code>applets[]</code> - Java applety
</li><li><code>forms[]</code> - formuláøe
</li><li><code>images[]</code> - obrázky
</li><li><code>links[]</code> - odkazy (<code class="htmll">&lt;a href="<i>URL</i>"&gt;...&lt;/a&gt;</code>)
</li></ul>
</p>

<h6>Vlastnosti <code>location</code>, <code>URL</code>, <code>referer</code></h6>
<p><code>location</code> je objekt obsahující informace o URL, ze které byl nahrán stávající dokument.
</p><p><code>URL</code> je textová hodnota obsahující URL, ze které byl nahrán stávající dokument.
Hodnota je stejná jako v <code>location.href</code> s vıjimkou pøípadu pøesmìrování poadavku ze strany serveru.
V takovém pøípadì je v URL pùvodní poadovaná adresa.
</p>

<h5>Objekt <code>window.document</code> jako koøenovı element stromu dokumentu</h5>
<p>Objekt Document a sada prvkù jím vystavovanıch skriptùm JavaScriptu tvoøí objektovı model dokumentu (DOM).
Bìhem historie vıvoje prohlíeèù byly vyvinuty rùzné objektové modely, co dodnes zpùsobuje potíe pøi snaze o
programování pøenositelnıch skriptù. Standardizace DOM se ujala organizace <a href="http://www.w3.org/DOM/">W3C</a>
a vytvoøila nìkolik tzv. úrovní standardu.
</p><p>DOM úrovnì 0 sice nebyl oficiálnì uveden ve formì doporuèení èi standardu.
Jedná se však o všeobecnì známou mnoinu schopností, kterımi vládly prohlíeèe
Netscape Navigator od verze 6.0 a Microsoft Internet Explorer od verze 4.0.
</p><p><a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/">DOM úrovnì 1</a> byl standardizován v roce 1998.
Definuje základní rozhraní jako Node, Element, Attr nebo Document, specifikuje rùzná rozhraní HTML elementù,
urèuje jednoduché zachytávání událostí.
</p><p><a href="http://www.w3.org/TR/2002/CR-DOM-Level-2-HTML-20021007/html.html">DOM úrovnì 2</a> je standard z listopadu 2000.
Znaènì rozšiøuje DOM 1. Zásadnì mìní zpùsob zachytávání událostí, pøidává nástroje pro práci s CSS, 
</p><p><a href="http://www.w3.org/TR/DOM-Level-3-Core/">DOM úrovnì 3</a> vznikl v roce 2004. Jedná se zatím spíše o teorii,
jediné prohlíeèe, které postupnì implementují jednotlivé moduly tohoto standardu, jsou produkty
<a href="http://www.mozilla.org/">Nadace Mozilla</a>.
</p><p>Bylo by ideální, pokud bychom se v praxi nemuseli zabıvat odlišnostmi v implementacích tohoto standardu.
Bohuel tomu tak není a je tøeba dávat pozor, jestli námi psanı kód funguje aspoò ve vìtšinì prohlíeèù.
</p>


</div>
			</div>
			<div>
				<a name="k-a-3-6"></a>
				<h4>A.3.3. Provázanost JavaScriptu s DOM</h4>
				<div><!-- JavaScript ve webovıch prohlíeèích / Provázanost JavaScriptu s DOM -->

<p>DOM neboli Document Object Model je standard sjednocující zpùsob, jakım se
programovì zachází se stromovou strukturou XML dokumentu. Jazyk HTML dlouhodobì smìøuje
k tomu, e bude vystavìn právì na XML.
(Co je XML? Viz mùj pøeklad èlánku <a href="http://www.dynawest.cz/xml/XMLv10bodech.htm">XML v deseti bodech</a>.)
Momentálnì je HTML vystavìno na základì pøedchùdce XML - jazyka SGML.
Nicménì i ten popisuje dokumenty formou stromové struktury, proto je mono
po parsování zdrojového kódu a pøevodu do stromové datové struktury DOM pouívat i na HTML.
</p><p>Standard DOM nedefinuje pøímo tøídy, èím by vıvojáøe implementací omezoval ve strukturálním návrhu jejich objektového modelu.
Místo toho je DOM vlastnì sada rozhraní, pomocí kterıch se dá se stromem manipulovat.
Definuje rozhraní <code>Node</code>, co je obecnı uzel stromu.
Dále definuje rùzná rozhraní, specializující jednotlivé uzly, jako napø.
<code>Document</code>, co je koøenovı uzel dokumentu,
<code>Element</code>, co je XML element,
<code>Attr</code> je atribut XML elementu, a další, detaily viz
<a href="http://www.w3.org/TR/REC-DOM-Level-1/">specifikace DOM úrovnì 1</a>.

</p><p>JavaScript se specifikace DOM ujal velice ladnì a elegantnì.
Místo jejího doslovného a slepého plnìní maximálnì vyuívá svıch dovedností.
Místo objektù kolekcí, ke kterım (a k jejich prvkùm) se pøistupuje pomocí metod,
pouívá svùj objekt pole. Místo volání metody <code><i>node</i>.getFirstChild()</code>
jednoduše ètete vlastnost <code><i>node</i>.firstChild</code>.
A podobnì je to u všech rozhraní DOM. Pracovat s objektovım modelem dokumentu
prostøednictvím JavaScriptu je oproti tìkopádnìjším jazykùm, jako napø. Java, je opravdu radost<!-- snadné -->. 

</p><p>Zájemce o podrobnosti odkazuji na kapitolu 17 knihy <a href="#zdroj_javascript">JavaScript - kompletní prùvodce</a>.
</p>
</div>
			</div>
			<div>
				<a name="k-a-3-3"></a>
				<h4>A.3.5. Provázanost JavaScriptu s HTML</h4>
				<div><!-- JavaScript ve webovıch prohlíeèích /  Provázanost JavaScriptu s HTML -->

<p>Kromì toho, e JavaScript disponuje moností manipulovat s jakımkoliv elementem
v dokumentu prostøednictvím DOM (viz kapitola <a href="#k-a-3-6">Provázanost JavaScriptu s DOM</a>),
v pøípadì HTML mùe bıt kadı uzel dále specializován a implementovat rozhrání náleející k pøíslušnému
typu elementu. Tato rozhraní je definováno jako modul standardu DOM.
Nìkteré elementy mìly v JavaScriptu reprezentaci ji od prvních verzí prohlíeèù s JavaScriptem.
Jako pøíklad si ukáeme tøídy Image a HTMLOptionElement.
</p>

<h5>Image</h5>
<p>Tøída <code>Image</code> byla jednou z historicky prvních tøíd
umoòujících manipulovat s objekty ve stránce.
V prvních verzích Navigatoru se reference na objekty Image
získávaly z pole <code>document.images[]</code> nebo
pomocí vlastností <code>document.<i>jméno_obrázku</i></code>.
Obsahuje nìkteré vlastnosti, se kterımi se zachází zvláštním zpùsobem:
</p>
<ul> <li><code>complete</code> - booleanová hodnota urèující, jestli prohlíeè dokonèil pokus o naètení obrázku.
</li><li><code>src</code> - pøi nastavené hodnoty na URL se zmìní obrázek, co se dá vyuít pro animaci a rùzné dynamické efekty.
</li></ul>
Dále je mono nastavit tøi ovladaèe událostí ve stylu DOM úrovnì 0:
<ul> <li><code>onabort</code> - vyvolá se, pokud uivatel bìhem naèítání obrázku tento proces zruší.
</li><li><code>onerror</code> - vyvolá se, kdy pøi stahování èi nahrávání obrázku dojde k chybì.
</li><li><code>onload</code> - vyvolá se, kdy je úspìšnì dokonèeno nahrávání obrázku.
</li></ul>


<h5>HTMLSelectElement</h5>
<p><code>HTMLSelectElement</code> patøí do sady rozhraní definovanıch standardem DOM.
Pøedstavuje HTML element <code class="htmll">&lt;select&gt;</code> neboli formuláøovı
prvek vıbìru. Opìt má kromì vlastností reprezentujících jeho atributy (jako <code>disabled</code>,
<code>multiple</code> nebo <code>name</code>) i speciální vlastnosti a metody umoòující
ovládat ho prostøednictvím JavaScriptu:
</p>
<ul> <li><code>options</code> - kolekce prvkù <code>HTMLOptionElement</code>, které pøedstavují poloky vıbìru.
</li><li><code>selectedIndex</code> - pozice vybrané poloky v rámci pole <code>options</code>.
Pøi zápisu èísla do vlastnosti se pøíslušná zmìna provede i v uivatelském rozhraní.
</li><li><code>add()</code> - pøidá do elementu novou poloku vıbìru.
</li><li><code>remove()</code> - odebere z elementu poloku vıbìru na zadané pozici.
</li></ul>

<p>HTML elementy <code class="htmll">&lt;select&gt;</code> jsou rovnì reprezentovány
tøídou <code>Select</code>, co je zpùsob práce s formuláøi v DOM úrovnì 0.
Monosti tøídy <code>Select</code> jsou podmnoinou moností tøídy <code>HTMLSelectElement</code>.
</p>


<h5>Další rozhraní DOM</h5>
<p>Standard DOM definuje mnoho rozhraní specializovanıch pro jeden typ èi skupinu typù elementu.
DOM úrovnì 1 jich definuje 62. Další informace jsou k dispozici ve
<a href="http://www.w3.org/TR/REC-DOM-Level-1/level-one-html.html">specifikaci DOM úrovnì 1, èást HTML</a>
a <a href="http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html">DOM level 1, ECMA Script Language Binding</a>.</p>
</div>
			</div>
			<div>
				<a name="k-a-3-4"></a>
				<h4>A.3.6. Provázanost JavaScriptu s CSS</h4>
				<div><!-- JavaScript ve webovıch prohlíeèích / Provázanost JavaScriptu s CSS -->

<p>Technologie CSS je velice mocná ji sama o sobì.
Jednoduchostí a prostotou základních principù,
ale obrovskımi monostmi pøi jejich poskládání pøipomíná JavaScript.
Kdy se pak tyto dvì technologie spojí, vzniká nesmírnì silnı nástroj
k dynamickému formátování dokumentù a vizuálních struktur obecnì.
</p><p>Struènì se seznámíme se zpùsoby, jakım JavaScript k CSS pøistupuje.
</p>

<h5>Vloené styly (inline)</h5>
<p>Prvky HTML mají atribut <code>style</code>. Obsahem tohoto atributu je text
formující platná pravidla CSS:
</p>

<pre><code class="html small_icon"><span class="c">&lt;div style="color: Gold;"&gt;</span>Ahoj lidi<span class="c">&lt;/div&gt;</span></code></pre>

<p>Pravidla stanovená v atributu <code>style</code> mají pøednost pøed styly definovanımi
v "listech stylù" (style sheets), tedy v prvcích <code class="htmll">&lt;style&gt;</code>
nebo v importovanıch CSS souborech.
</p><p>CSS vlastnosti prvkù mají svùj ekvivalent také v stromové struktuøe dokumentu.
Kadı HTML prvek má také vlastnost <code>style</code>, ve které jsou zjistitelné a zmìnitelné
veškeré implementované CSS vlastnosti. Jedná se o objekt tøídy <code>CSSStyleDeclaration</code>.
</p><p>Barvu písma prvku v pøedchozí ukázce zjistíme a zmìníme takto:
</p>

<pre><code class="js"
><span class="f">alert</span>(oDiv.style.color);        <span class="cml">// Zobrazí "Gold"</span>
oDiv.style.color = <span class="s">"LawnGreen"</span>; <span class="cml">// Nastaví barvu na "LawnGreen"</span>
</code></pre>

<p>Nìkteré vlastnosti CSS jsou celkem komplexní, jako napøíklad border.
Takové se potom rozkládají a na jednotlivé atomické èásti, napø. <code>style.borderBottomWidth</code>.
</p>


<a name="k-a-3-4-listy_stylu"></a>
<h5>Listy stylù</h5>
<p>Ovládat styly konkrétních prvkù je uiteèné, ale tu pravou sílu spojení JavaScript + CSS
ovládnete a s moností definovat a mìnit obecná pravidla v listech stylù.
</p>
<h6>Procházení listy stylù</h6>
<p>Podobnì jako lze procházet elementy v dokumentu, i CSS pravidla jsou rozèlenìna do stromové struktury.
Mùete k nim pøistupovat pomocí kolekce <code>document.styleSheets[]</code>. Tato kolekce obsahuje
informace z jednotlivıch blokù CSS kódu, tedy z elementù <code class="htmll">&lt;style&gt;</code>
a dále CSS soubory pøièlenìné elementem <code class="htmll">&lt;link&gt;</code>.
</p><p>Kadı prvek této kolekce je objekt tøídy StyleSheet. V dokumentech HTML implementují tyto objekty
rozhraní CSSStyleSheet, které zpøístupòuje jednotlivé CSS vlastnosti. Kadı prvek tedy má vlastnost
<code>cssRules[]</code>, co je opìt kolekce, tentokrát objektù CSSRule.
</p><p>V CSS se mohou objevit pravidla, která se vymykají tìm "bìnım" - napøíklad <code>@media</code>
nebo <code>@import</code>. Taková pro struènost vynecháme a budeme se vìnovat právì tìm bìnım.
Ta se poznají tak, e jejich objekt CSSRule má vlastnost <code>type</code> s hodnotou konstanty
<code>CSSRule.STYLE_RULE</code>. Pokud je tomu tak, objekt implementuje rozhraní <code>CSSStyleRule</code>
a tím pádem má vlastnost style, co je objekt tøídy <code>CSSStyleDeclaration</code>, co je ten samı typ objektu, jako 
je v hodnotì <code>style</code> kadého HTML elementu.
</p><p>Nyní si pøedvedeme, jak vyuít vıše vysvìtlená fakta v praxi:
</p>

<pre><code class="js"
><span class="cml">// Najdeme první pravidlo v prvním bloku CSS kódu</span>
<span class="cml">// (pøedpokládáme, e existuje)</span>
<span class="k">var</span> oPravidlo = document.styleSheets[<span class="n">0</span>].cssRules[<span class="n">0</span>];
<span class="k">var</span> oStyl;
<span class="cml">// Pokud se jedná o bìné pravidlo,
// nastavíme barvu pozadí na pìknou modrou</span>
<span class="k">if</span>(oPravidlo.type == CSSRule.STYLE_RULE){
  oPravidlo.style.backgroundColor = <span class="s">"LightSkyBlue"</span>;
}
</code></pre>

<p>Pøíklad najdete v souboru <a href="priklady/p-a-3-4-listy_stylu.html">p-a-3-4-listy_stylu.html</a>.
</p>


</div>
			</div>
			<div>
				<a name="k-a-3-5"></a>
				<h4>A.3.7. Provázanost JavaScriptu s Cookies</h4>
				<div><!-- JavaScript ve webovıch prohlíeèích / Provázanost JavaScriptu s Cookies -->

<p>Objekt <a href="#k-a-3-2"><code>window.document</code></a> obsahuje vlastnost <code>cookie</code>.
Bez podrobnìjšího zkoumání se zdá, e je to prostá øetìzcová hodnota.
Prohlíeèe však s touto vlastností zacházejí zvláštním zpùsobem.
</p>

<h5>Cookies v protokolu HTTP</h5>
<p>Tzv. <i>cookie</i> je technika pøevzatá z protokolu HTTP. Jeliko je tento protokol bezestavovı,
pøi vzniku potøeby uchovat od jednoho poadavku ke druhému nìjaká data bylo tøeba vymyslet zpùsob, jak to provést.
Pøidávat tato data do kadého odkazu v dokumentu je neefektivní a navíc se jedná o potenciální bezpeènostní riziko
(viz mùj <a href="http://ondra.zizka.cz/projekty/xss/">èlánek o XSS - Cross Site Scripting</a>).
Bohuel dodnes je to nìkdy tøeba, protoe dezinformovaní uivatelé vidí v cookies hrozbu pro jejich poèítaè,
za co mùe poèáteèní chaos v implementacích cookies zejména na proxy serverech, ale i v prohlíeèích.
</p><p>Vymyšlenı a pøijatı pùsob uchování dat spoèívá ve vımìnì dvou hlavièek HTTP protokolu mezi serverem a prohlíeèem.
</p>

<h6>Zápis</h6>
<p>Server posílá hlavièku <code class="http line">Set-Cookie: <i>data a metadata</i></code> v tomto tvaru:
</p>

<code class="http block">Set-Cookie: <i>jméno</i>=<i>hodnota</i>[; expires=<i>datum</i>[;
          path=<i>cesta</i>[; domain=<i>doména</i>[; secure]]]]</code>

<p>S hlavièkou má prohlíeè naloit podle pravidel standardu. Ten ukládá povinnost uloit obsaená data
za pomìrnì dost omezenıch podmínek, které jsou stanoveny podle situace v dobì vzniku technologie - 
napøíklad povinnı minimální poèet uchovávanıch cookies je pouhıch 300. To znamená, e pokud má vydret
jedna cookie uchovaná aspoò 30 dnù, mùe uivatel navštívit v prùmìru maximálnì 10 serverù dennì,
které ukládají cookies. Jeliko se však jedná o technologii vyuívanou prakticky kadım serverem
pro takzvané <i>sessions</i> neboli sezení, navíc nìkteré (zejména reklamní) servery ukládají cookies
z rùznıch subdomén,
tento limit je snadno pøekroèen a prohlíeè u podle standardu mùe nejstarší cookies mazat.
Naštìstí moderní prohlíeèe ji na novou situaci reagovaly a pravidla pro uchovávání cookies se øídí
i jinımi pravidly ne poèetními.
</p><p>Tìchto hlavièek mùe prohlíeè poslat více, a to i najednou. Prohlíeè je ukládá všechny
a pøi odesílání na server je sloí do jedné hlavièky <code>Cookie</code> - viz dále.
</p>

<h6>Ètení</h6>
<p>Pøi kadém poadavku prohlíeè kontroluje kadou uloenou cookie, zda poadavek splòuje jí nastavené poadavky:
<ul> <li>doména odpovídá èásti <code>domain</code>
</li><li>cesta odpovídá èásti <code>path</code> nebo je hierarchicky pod ní
</li><li>aktuální èas nepøekroèil datum expirace v èásti <code>expires</code>
</li></ul>
Pokud poadavek vyhovuje, pošle prohlíeè serveru hlavièku Cookie sloenou ze všech vyhovujících cookies:
<code class="http block">Cookie: <i>jméno1</i>=<i>hodnota1</i>; <i>jméno2</i>=<i>hodnota2</i>; ... </code>
</p>

<h6>Podrobnosti</h6>
<p>Podnìjší informace o technologii cookies najdete v
<a target="_blank" href="http://wp.netscape.com/newsref/std/cookie_spec.html">dokumentu od Netscape</a>,
nebo <a target="_blank" href="http://www.reference.com/Dir/Computers/Programming/Internet/Cookies/">www.reference.com</a>,
pøípadnì v samotné specifikaci
<a target="_blank" href="http://www.zvon.org/tmRFC/RFC2965/Output/index.html">HTTP State Management Mechanism</a>.
</p>

<h5>Cookies v JavaScriptu</h5>
<p>Ohlednì dùvìryhodnosti si JavaScriptové programy s komunikací se servery mnoho nezadají - jedná se o kód
posílanı ze serveru a vykonávanı u klienta. Proto nemùe bıt o pøímém zápisu do souborového systému ani øeè.
Nicménì potøeba doèasnì uloit data je u JavaScriptovıch programù také. Proto byl v prohlíeèích implementován
jednoduchı mechanismus: Pokud nastavíte vlastnost <code>document.cookie</code>, prohlíeè se zachová naprosto
stejnì, jako by ze serveru dostal HTTP hlavièku <code>Set-Cookie</code> se stejnou hodnotou.
Pøi ètení této vlastnosti vrátí prohlíeè stejnı øetìzec, jakı by poslal na server jako hodnotu hlavièky <code>Cookie</code>.

</p><p>Ukázka funkce cookies v JavaScriptu je v <a href="priklady/k-a-3-5-cookies.html">pøíkladu</a> - zejména si prohlédnìte zdrojovı kód.

</p></div>
			</div>
			<div>
				<a name="k-a-3-7"></a>
				<h4>A.3.8. Provázanost JavaScriptu s Javou</h4>
				<div><!-- JavaScript ve webovıch prohlíeèích / Provázanost JavaScriptu s Javou -->

<p>Vztah mezi JavaScriptem a Javou mi pøipomíná vztah Asterixe a Obelixe.
Kde je druhı pøíliš tìkopádnı, neohrabanı a jeho nasazení zbyteèné,
nastupuje první, mrštnı, flexibilní, pøizpùsobivı, i kdy znaènì odlehèenı kolega.
JavaScript skuteènì pøevzal úlohu, pro kterou byla pùvodnì urèena Java.
Kdy se však ukázalo, e spouštìt nìkolikamegabajtovı virtuální stroj Javy
jenom kvùli kontrole, zda ve formuláøi nezbıvá nìjaká nevyplnìná poloka, není úplnì vhodné øešení.
</p><p>Proto se vıvojáøi firmy Netscape zamìøili na vıvoj nìèeho, co by úkol Javy zastalo.
V prohlíeèi Navigator tak spatøil svìtlo svìta JavaScript 1.0 (viz podkapitola A.I.2.c - <a href="#k-a-1-2">Historie JavaScriptu</a>).
</p><p>JavaScript dodnes zùstal v prohlíeèích nástrojem malım, mrštnım a flexibilním; zùstala mu však i odlehèenost.
Je mnoho úkolù, které v bìnıch skriptech nezvládá, protoe mu nebyly svìøeny z bezpeènostních dùvodù
(napø. komunikace pøes sí pomocí socketù, zápis do souborù), nebo na nì není stavìnı
(napø. vytváøení rastrové grafiky, komprese dat èi zvuku) - i kdy dnes by je díky vıkonùm
poèítaèù a kvalitì nìkterıch implementací (napø. v prohlíeèích Nadace Mozilla) pravdìpodobnì zvládnul.
Na tyto úkoly je nadále nasazována Java v podobì Java Appletù.
</p><p>Proè ovšem dìlat Javou vše, proè jí nenechat skuteènì to nejnutnìjší,
a na jednoduché úkony a obsluhu klienta nadále nepouívat k tomu vhodnìjší JavaScript?
Zøejmì takovou otázku si poloili vıvojáøi firem Netscape a
<a href="http://www.sun.org/">Sun</a> (<a href="http://java.sun.org/">tvùrce Javy</a>)
a vytvoøili nejprve technologii <a href="http://wp.netscape.com/eng/mozilla/3.0/handbook/plugins/">LiveConnect</a>
(dnes je <a href="http://www.mozilla.org/js/liveconnect/">lepší dokumentace na stránkách Nadace Mozilla</a>),
nitky z Javy do JavaScriptu, a pozdìji implementovali do Javy páky k obsluze JavaScriptu
(tøídy <code>JS*</code> v balíku <code>netscape.javascript</code>).
</p><p>
První technologie umoòovala nejprve èíst a zapisovat veøejné èleny objektù a volat veøejné metody.
Pozdìji umonila i pouívání tøíd Javy k instanciování objektù v prostøedí JavaScriptu.
Pøi programování tøíd, které se mají v JavaScriptu pouívat, je tøeba mít na pamìti
odlišnosti obou jazykù, zejména slabou typovost JavaScriptu oproti silné typovosti Javy,
a z toho plynoucí rizika omezení - napøíklad s pøetìováním metod.
</p><p>
Druhá technologie je o poznání sloitìjší a její motivace by se mohla zdát slabší,
ovšem vyuije se v pøípadì aplikací napsanıch v Javì, které pouívají JavaScript
jako svùj skriptovací jazyk (tímto smìrem se moná vydá projekt <a href="http://eclipse.org/">Eclipse</a>).
</p>
</div>
			</div>
			<div>
				<a name="k-a-3-8"></a>
				<h4>A.3.9. Provázanost JavaScriptu s Flashem</h4>
				<div><!-- JavaScript ve webovıch prohlíeèích / Provázanost JavaScriptu s Flashem -->

<p>Rovnì technologie <a href="http://www.macromedia.com/software/flash/">Flash</a>
firmy <a href="http://www.macromedia.com/">Macromedia</a> vykroèila smìrem k otevøení se
JavaScriptu prostøednictvím LiveConnect. Bohuel tato technologie není zatím pøíliš zdaøilá
a nepodaøilo se nám ji zprovoznit. Zájemci se mohou pokusit podle èlánku
<a href="http://aktuell.de.selfhtml.org/artikel/programmiertechnik/liveconnect/">LiveConnect zwischen JavaScript und Flash-ActionScript</a>.
</p><p>Existuje ještì jedna technologie spojující JavaScript a Flash - <a href="http://www.x-flash.org/as/docs/extensibilidad1.htm">JSFL</a>.
Jak se praví na oné stránce:
</p>

<p class="block quote" lang="es">
JSFL (Java Script Flash) es el nuevo lenguaje de extensibilidad creado por Macromedia
basado en Javascript de Netscape que permite manejar el DOM del Flash y extender las herramientas
o comandos que el programa posee, es un lenguaje que sólo se puede usar en el programa no en el compilado (swf)
es lo que lo diferencia del Action Script.
En palabras más sencillas: es un nuevo lenguaje que te permite manejar el programa mismo del Flash,
automatizando tareas o creando herramientas.
</p>

<p>Nejedná se tedy o provázání JavaScriptu s Flashem, nıbr o vyuití JavaScriptu ve Flashi
jako skriptovacího jazyka pro ovládání vıvojového prostøedí (nikoliv jako náhradu za ActionScript!).
</p>
</div>
			</div>
			<div>
				<a name="k-a-3-9"></a>
				<h4>A.3.10. Provázanost JavaScriptu s SVG</h4>
				<div><!-- JavaScript ve webovıch prohlíeèích / Provázanost JavaScriptu s SVG -->
	 
<h5>Co je SVG</h5>
<p>SVG neboli Scalable Vector Graphic je popisnı jazyk zaloenı na XML, kterı je urèen pro popis vektorové grafiky.
Jinımi slovy je to otevøenı grafickı vektorovı formát s podobou XML dokumentu.
Vıhody SVG v praxi struènì a vıstinì pøedstavuje <a href="http://www.adobe.com/svg/overview/svg.html">prezentace SVG od firmy Adobe</a>,
další prezentace obsahuje <a href="http://www.adobe.com/svg/demos/main.html">efektní a propracované ukázky pouití SVG</a>.

</p><p>SVG je nadìjná technologie, která je podle mého názoru posledním chybìjícím pilíøem
mostu XHTML + CSS + SVG + JavaScript, po kterém forma webovıch stránek pøejde
od statické letákovo-katalogové podoby
k efektním ivım prezentacím ve stylu Flashe a k vıkonnım tenkım klientskım aplikacím,
a Flash bude postupnì nahrazen.

</p><p>SVG má také svùj standard od W3C - <a href="http://www.w3.org/TR/SVG/">specifikaci SVG</a>.
</p><p>Ukázka kódu a vısledek v rohu:
</p>

<pre><code id="svg_circles" class="svg block">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" 
        "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;
&lt;svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"&gt;
  &lt;g fill-opacity="0.7" stroke="black" stroke-width="0.1cm"&gt;
 &lt;circle cx="6cm" cy="2cm" r="100" fill="red" transform="translate(0,50)" /&gt;
 &lt;circle cx="6cm" cy="2cm" r="100" fill="blue" transform="translate(70,150)" /&gt;
 &lt;circle cx="6cm" cy="2cm" r="100" fill="green" transform="translate(-70,150)"/&gt;
  &lt;/g&gt;
&lt;/svg&gt;</code></pre>

<h5>Proè je SVG stále undergroundovou záleitostí?</h5>
<p>Bohuel však SVG velice trpí dosavadním ne pøíliš velkım zájmem komerèních firem o jeho nasazení.
Nìjakou dobu byla tahounem technologie ji zmínìná firma <a href="http://www.adobe.com/">Adobe</a>
se svou aplikací èi spíše pluginem <a href="http://www.adobe.com/svg/viewer/install/main.html">SVG Viewer</a>
a nìkolika dalšími svımi <a href="http://www.adobe.com/svg/viewer/install/main.html">aplikacemi s podporou SVG</a>.
Vıvoj SVG Vieweru se ovšem zastavil na <a href="http://www.adobe.com/svg/overview/whatsnew.html">verzi 3.0</a>,
která je plná chyb a zejména co se zájmu této práce tıká, tedy pouitelnosti JavaScriptu pro ovládání SVG,
je tento plugin spíše nepouitelnı.
</p><p>V souèasnosti je s implementací zobrazování SVG nejdále nejspíše
<a href="http://www.mozilla.org/projects/svg/">Nadace Mozilla</a>.
Jejich cílem je plná implementace standardu W3C SVG 1.1.
Implementace verze 1.0 pøechází z fáze vıvoje do fáze testování.
K testovacím úèelùm je mono si <a href="http://www.mozilla.org/projects/svg/build.html">stáhnout prohlíeè s podporou SVG</a>.
V brzké dobì se plánuje zaèlenìní podpory SVG do ostré verze
<a href="http://www.mozilla.org/products/firefox/central.html">prohlíeèe Firefox</a>.
Tomu nasvìdèuje i upozornìní, které se nedávno objevilo na stránce projektu Mozilla SVG:
</p>

<p class="block quote">There has recently been an important change to SVG enabled builds.
SVG enabled builds now require you to set the 'svg.enabled' pref to 'true' before they will render SVG.
</p>


<h5>Další zdroje</h5>
<ul> <li>Revelon's SVG Page: <a href="http://www.guide.cz/svg/">www.guide.cz/svg</a>
</li><li>SVG forum: <a href="http://www.svg-cafe.com/">www.svg-cafe.com</a>
</li></ul>
</div>
			</div>
			<div>
				<a name="k-a-3-10"></a>
				<h4>A.3.11. Bezpeènost JavaScriptu</h4>
				<div><!-- JavaScript ve webovıch prohlíeèích /  -->

<p>JavaScript sám o sobì je celkem bezpeènı, zejména kvùli všem rùznım omezením schopností,
která jsou provádìna právì ve jménu bezpeènosti. Nejèastìjší zneuití JavaScriptu tak
spoèívá v otravování uivatelù prohlíeèe vyskakujícími okny, nevkusnımi animacemi,
zmìnami velikosti okna a podobnì.
</p><p>Pøesto, prostøedí prohlíeèe je nesmírnì sloité a vıvojáøùm tak mùe uniknout
nìjaká skulina, kterou je mono zneuít proti uivateli prohlíeèe.

Napøíklad nedávno byla objevena
<a href="http://www.webpronews.com/news/ebusinessnews/wpn-45-20050405JavaScriptVulnerabilityFoundInFirefox.html"
>bezpeènostní chyba ve Firefoxu</a> zpùsobená špatnou prací s pamìtí. Vısledkem je, e pøi nìkterıch operacích
s øetìzci se mùe na jejich konci objevit obsah náhodné èásti pamìti. Šance, e na onom místì v pamìti
budou nìjaká závaná data, je skoro nulová, a Microsoft by takovou vìc oznaèil za vylepšení, nicménì pro
Nadaci Mozilla je to dostateènı dùvod k uvolnìní nové verze prohlíeèe.
</p>

<img src="img/screenshot_firefox_fixed.gif" alt="" width="575" height="341" class="border">

<p>Nejèastìjší zneuití JavaScriptu ovšem spoèívá v tom, e se nìjakı server snaí maskovat jako
jinı server, nebo pozorovat vaši práci na jiné stránce, a pøinutit uivatele, aby v domnìní,
e komunikují se správnım serverem nebo bez jeho vìdomí, e jeho akce na stránce jsou sledovány skriptem,
vydali citlivé informace, jako napøíklad heslo nebo èíslo kreditní karty.
Tento druh útokù se obecnì nazıvá Cross Site Scripting (XSS)
(viz mùj <a href="http://ondra.zizka.cz/projekty/xss/">èlánek o tomto tématu</a>).
Právì proti takovımto pokusùm je míøena vìtšina bezpeènostních omezení moností JavaScriptu.
</p>
</div>
			</div>
		</div>
	</div>
	<!-- Teoretická èást - KONEC -->
	
	<hr />
	
	<!-- B. Praktická èást -->
	<div class="cast_teorie">
		<a name="k-b"></a>
		<h2>B. Praktická èást</h2>
		<div>
			<div><!-- B. Praktická èást  -->

<p>V teoretické èásti jsme pøedstavili JavaScript jako sofistikovanı jazyk s více ne dobrou schopností
vyjádøit vše, co je dnes k bìnému programování tøeba a dokázali jsme, e svımi monostmi nezaostává
za jinımi programovacími jazyky a je ho mono pouít pro programování klientskıch aplikací.

</p><p>V této èásti pøejdeme od teorie k praxi a pøedvedeme nìkolik aplikací,
které skuteènì JavaScript pouívají.

<!-- Nejprve provedeme rozbor aplikace MinerJS, -->
Provedeme rozbor aplikace Miner JS,
hry, která byla napsána vıhradnì za pouití <!-- standartních --> prostøedkù klientského
programování v prohlíeèích v dokumentech HTML, a která byla vytvoøena pøevánì
pro úèely této bakaláøské práce.

<!-- Dále se seznámíme s projektem FlexiNet, univerzální vnitropodnikové informaèní aplikace.

Nakonec se pokusíme proniknout do projektu Mozilla Calendar, aplikace vystavìné na bázi
Aplikaèní kostry Mozilla (Mozilla Application Framework). -->
</p>
</div>
		
			<a name="k-b-1"></a>
			<h3>B.1. Miner JS</h3>
			<div><!-- B. Praktická èást / MinerJS -->

<p>JavaScriptová aplikace Miner JS je hra vytvoøená vıhradnì s pouitím prostøedkù klientského programování
v prohlíeèích (viz kapitola <a href="#k-a-3">JavaScript ve webovıch prohlíeèích</a>).
Byla naprogramována jako praktická èást této bakaláøské práce za úèelem demonstrace
moností JavaScriptu v prohlíeèích.

</p><p>Soubory potøebné pro spuštìní hry se nachází na CD pøiloeném k tištìné verzi této práce.
Aktuální verze je na internetové adrese
<a target="_blank" href="http://ondra.zizka.cz/projekty/miner/">http://ondra.zizka.cz/projekty/miner/</a>.
Upozoròuji, e hra je vyvíjena na základì obecnì uznávanıch standardù sdruení W3C, které ovšem
nìkteøí vırobci prohlíeèù nerespektují. Proto hra ve stavu v dobì dokonèení této práce v nìkterıch
prohlíeèích nefunguje - zejména v Microsoft Internet Exploreru. Níe budou objasnìny dùvody a vysvìtleny podrobnosti.
Blíe také viz v èásti této kapitoly <a href="#k-b-1-1">Historie vıvoje hry</a>.

</p><p>
<img class="left" src="img/firefox_white.jpg" alt="" width="60" height="60" />
Pro vyzkoušení hry Miner JS (i jako prohlíeè obecnì) silnì doporuèujeme prohlíeè
<a href="http://www.mozilla.org/products/firefox/">Firefox</a>.

</p>
</div>
			
			<div>
				<a name="k-b-1-1"></a>
				<h4>B.1.1. Historie vıvoje hry</h4>
				<div><!-- MinerJS / Historie vıvoje hry -->

<h5>Pùvodní hra</h5>

<img class="border right" src="img/screenshot_miner_01.gif" alt="Miner VGA - screenshot" width="320" height="240" />
<p>Námìt hry není originální. Jedná se o pøedìlávku staré hry
<a href="http://www.bhlegend.com/php/show.php3?game=1204">Miner VGA</a>
(<a href="http://www.dosgamesonline.com/index/game/Miner%20VGA/116/">2</a>) z roku 1989 od
<a href="http://www.beachnet.com/~hstiles/">Harrela W. Stillese</a>.

</p><p>Hru pøedstaví vlastními slovy sám tvùrce:
</p>


<blockquote lang="en-US" style="display: none;">
<p>"The object of the game is to "make a lady" out of Miss Mimi, the owner of the brothel. If this sounds too sexist for you, you might want to quit reading now and not play.
</p><p>In essence, she has agreed to marry you IF you present her with a diamond ring and $20,000 in cash (your mutual retirement fund.) "Anything less and I would be wasting my god given talents on just one man.", says she. Because of her history of unsanitary sexual practices you may also want to consider having a condom as well.
</p><p>You win the game when you present yourself to Miss Mimi with $20,000 and a diamond ring. The toughest part, of course, is mining enough ore to come up with the $20,000."
</p>
</blockquote>

<div class="block quote" lang="cs-CZ">
<p>"Cílem této hry je "udìlat dámu" ze sleèny Mimi, bordelmamá z místního nevìstince.
Pokud se vám to zdá pøíliš sexistické, moná radìji pøestaòte èíst a hru nehrajte.
</p><p>Sleèna Mimi není v zásadì proti sòatku s vámi, POKUD do nìj pøinesete prsten s diamantem a dvacet tisíc dolarù v hotovosti
(váš dùchodovı fond). 'Cokoliv ménì by bylo plıváním mımi od boha danımi talenty jen na jediného mue', øíká.
Kvùli její minulosti nehygienickıch sexuálních praktik by také bylo vhodné zváit také opatøení ochrany.
</p><p>Hru vyhráváte ve chvíli, kdy pøijdete za Mimi s poadovanımi dvaceti tisíci dolary a prstenem s diamantem.
Nejtìší èást, samozøejmì, je vytìit dostatek rud, abyste shromádili onìch 20 000."
</p><p class="popisek">(pøevzato ze serveru bhlegend.com)
</p>
<div class="clearb"></div>
</div>

<p>Ani tato hra však není pùvodní, jedná se o pøedìlávku textové hry ze sedmdesátıch let pro poèítaè Commodore Pet:</p>
	<div class="block quote" lang="en-US">
		<p>
		The game was originally implemented on a Commodore Pet
		computer in the late 70's as a text only style game.
		The current version encompasses more than the original version,
		but much of the charm remains intact.  I&nbsp;wrote and released
		another PC miner game (text only) several years back. That
		earlier version was primitive and bears little resemblance
		to the current (hopefully better) one. For this version
		I&nbsp;started from scratch in&nbsp;a&nbsp;different language and used only
		VGA screen modes. My personal goal with this program was to
		gain experience working with the graphics technology of&nbsp;the VGA&nbsp;card.
		</p><p>
		I would be very interested in locating the original
		programmer of the Commodore version if anyone has any clues.
		</p>
		<p class="popisek">Harrel W. Stilles, readme soubor k Miner VGA (v pøíloze)</p>
	</div>

<p>Tuto starou textovou hru u se bohuel vypátrat nepodaøilo.
Moná bychom ale nakonec dospìli ke zjištìní, e se úplnì pùvodní hru
hráli ji staøí Egypané s kamínky na papyrovém herním plánu.

</p><p>DOSová verze od H. Stillese byla napsána v programovacím jazyku MS&nbsp;Quick&nbsp;Basic&nbsp;4.0.
Najdete ji na CD pøiloeném k tištìné verzi práce a také na internetu na adrese
<a href="http://ondra.zizka.cz/projekty/miner/minervga.zip">http://ondra.zizka.cz/projekty/miner/minervga.zip</a>.
Na CD a&nbsp;na&nbsp;adrese <a href="http://dosbox.sourceforge.net/">http://dosbox.sourceforge.net/</a> je také
DosBox&nbsp;0.63 - emulátor DOSu pro mnoho platforem.
Dále na CD a na adrese <a href="http://members.home.nl/mabus/">http://members.home.nl/mabus/</a>
je D-Fend&nbsp;2.0.62.42 - nástroj pro pouití DosBoxu.
</p>

<h5>První pokus</h5>
<p>Mùj první pokus o pøedìlání hry do JavaScriptu probìhl pravdìpodobnì (podle data zmìny nejstarších souborù)
v prosinci roku 1998.
Vytìil jsem grafickou verzi H.&nbsp;Stillese jak to šlo, tedy vyjmul jsem z ní grafické prvky,
a zkusil je poskládat v oknì prohlíeèe.
Bohuel vıkon tehdejších poèítaèù a zøejmì i optimalizace JavaScriptu nebyly na dostateènì vysoké úrovni na to,
aby zvládaly zobrazení a obsluhu nìkolika set obrázkù. Na poèítaèi, na kterém jsem tehdy pracoval,
trvalo jen naètení stránky do vıchozího stavu zhruba devìt minut, obsluha pohnutí panáèkem zabrala
kolem deseti sekund, a navíc hra pomìrnì èasto zpùsobila pád Internet Exploreru (tehdy verze&nbsp;4.0).
Svoje snahy jsem tedy zabalil do archivu <code class="file">miner.zip</code> a opustil je.
</p>

<h5>Druhı pokus</h5>
<p>O ètyøi roky pozdìji, v&nbsp;listopadu 2002, jsem se nìjakou náhodou, zøejmì pøi pøesunu
svıch souborù na svùj první vlastní poèítaè, dostal k archivu <code class="file">miner.zip</code>.
Ze zvìdavosti jsem zkusil, jak dlouho bude naèítaní oné stránky trvat nyní,
na poèítaèi s procesorem Pentium&nbsp;4 na&nbsp;1500 MHz a v Internet Exploreru&nbsp;6.0.
K mému pøekvapení trvalo naètení jen kolem dvaceti sekund a 
obsluha hnutí panáèkem trvala tak krátce, e by se dala prohlásit za okamitou.
</p><p>Toto poznání mì nadchnulo a jeliko jsem v tu dobu zrovna nemìl moc co dìlat,
pustil jsem se do programování hry. Bohuel tehdy moje znalosti JavaScriptu
nebyly valné a jeho implementace v Internet Exploreru&nbsp;6.0 byla (a&nbsp;je) mizerná.
Skonèil jsem tedy s nìkolika desítkami stránek nepøehledného nestrukturovaného kódu
a další pokusy o vylepšování hry vedly jen k stále èastìjším chybám a vìtšímu chaosu.
Celı projekt tedy opìt šel do archivu, tentokrát <code class="file">miner.rar</code>,
a&nbsp;byl pøesunut do&nbsp;adresáøe opuštìnıch projektù.
</p>

<h5>Tøetí pokus</h5>

<p>Další skok ve vıvoji hry nastal po èervnu 2003.
Ji døíve jsem se dozvìdìl o existenci prohlíeèe Mozilla, je jsem nyní nainstaloval a vyzkoušel.
Prakticky okamitì jsem ho pøijal jako náhradu za Internet Explorer, jeliko z uivatelského hlediska
se jednalo o neporovnatelnì lepší program.
Jako vıvojáø webù jsem stránky testoval i&nbsp;v&nbsp;tomto prohlíeèi, a&nbsp;velice rychle jsem zjistil,
e rozdíl jeho kvality od MSIE z hlediska vnitøní funkènosti je ještì o nìkolik øádù vìtší, ne u
klientského rozhraní.
</p><p>V záøí 2003 jsem si opìt vzpomnìl na nedávné trápení s Internet Explorerem pøi vıvoji hry Miner JS.
Rozbalil jsem archiv <code class="file">miner.rar</code> a zkusil jsem, jak se bude tato hra chovat v prohlíeèi Mozilla.
Podle oèekávání bylo v kódu mnoho nestandardních prvkù, zejména pouití kolekce <code>all</code>.
Nicménì po pracném a úmorném pøizpùsobení zaèala hra v Mozille fungovat stejnì, jako pøedtím v MSIE.

</p><p>Transformace kódu mì donutila vytvoøit èistší a strukturovanìjší kód.
Tímto proèištìním se otevøela cesta k dalšímu vıvoji, ani by dále rostl chaos.
Nìkolik tıdnù jsem hru vylepšoval a pøidával nejnutnìjší funkce jako inventáø,
obchod, nemocnici, tìbu a podobnì.
</p><p>Na tomto místì bych rád podìkoval svım dvìma betatesterùm:
</p>
<ul> <li>Tomaši Náhlíkovi, spolustudentovi z oboru, kterı mi hlásil chyby a poskytl dùleitı
náhled nezúèastnìné osoby.
</li><li>Lucce Hanzálkové, které se velmi zalíbila pùvodní DOSová verze H. Stillese,
a&nbsp;paralelnì zkoušela hrát mojí JavaScriptovou verzi. Já sám jsem nikdy pøíliš
pùvodní verzi nehrál, take jsem nedokázal správnì nastavit rùzné koeficienty,
pøímo ovlivòující obtínost hry, zejména pravdìpodobnost vıskytu jednotlivıch
rud, hornin a podzemních jevù, a prodejní cenu hornin.
</li></ul>
<p>Obìma dìkuji a doufám, e mi ještì hru pomohou doladit po jejím dokonèení.
</p><p>Toto období vıvoje pokraèovalo pomìrnì rychlım tempem do doby,
kdy se zaèalo blíit zkouškové období zimního semestru,
termíny odevzdání semestrálních prací a&nbsp;navíc bylo tøeba pracovat na komerèních projektech.
Po nìkolika tıdnech tak vıvoj opìt ustal.
</p>

<h5>Realizace</h5>

<p>Poslední a dosud trvající krok ve vıvoji hry zaèal na jaøe 2004. Tehdy jsem koupil knihu 
<a href="#zdroj_javascript">JavaScript - kompletní prùvodce</a> od Davida Flanagana.
Tato kniha je nìco jako Bible JavaScriptu, kterı velice vyèerpávajícím zpùsobem popisuje.
Navíc postoupila doba a JavaScript se hodnì vyvinul &ndash;
viz pøedmluva knihy:
</p>
<ul> <li>Bylo publikováno druhé a tøetí vydání specifikace ECMA-262.
</li><li>Byl uvolnìn zdrojovı kód interpreteru JavaScriptu od spoleènosti Netscape.
</li><li>Konsorcium W3C vydalo specifikaci DOM (viz kapitola <a href="#k-a-3-6">Provázanost JavaScriptu s DOM</a>).
</li><li>Organizace Mozilla vytvoøila prohlíeè se zatím nejlepší implementací JavaScriptu a dalších potøebnıch standardù.
</li></ul>

<img class="right" src="img/zdroje/javascript.jpg" alt="JavaScript - kompletní prùvodce - obálka" width="150" height="197" />
<p>Podmínky pro vıvoj komplexních aplikací v JavaScriptu se tedy vıraznì zlepšily
a&nbsp;existuje minimálnì jeden prohlíeè, u kterého se mùete spolehnout,
e&nbsp;váš kód bude provádìt korektnì a bìhem vıvoje aplikace nenarazíte na záhadnou chybu,
která se pro váš projekt stane nepøekonatelnou pøekákou.

</p><p>Pøi ètení knihy jsem si velice ivì vybavil svoje problémy pøi vıvoji hry Miner JS - 
od posledního pokusu ubìhlo jen asi pùl roku.
U pøi ètení prvních kapitol èásti o jádru JavaScriptu mì napadaly zpùsoby,
jak vyøešit konkrétní problémy, a&nbsp;nemohl jsem se udret u ètení nedoèkavostí, a zkusím
øešení v praxi. (Správné programátorské zapálení :-) Èasem mi v mysli vykrystalizoval
zcela novı objektovı model hry, jak&nbsp;by&nbsp;mohl fungovat.

</p><p>Paralelnì se tou dobou blíil poslední monı termín odevzdání zadání bakaláøské práce.
Vybíral jsem mezi nìkolika tématy, ale nejbliší mi v tu dobu z vıše popsanıch pohnutek byla právì
hra Miner JS. Na realizaci jsme se dohodli s doktorem Ing. Janem Járou, kterı docenil
téma JavaScriptu a uznal formu hry jako ideální ukázku síly skriptovacího jazyka.

</p><p>Zaèal jsem tedy pracovat na implementaci objektového modelu hry.
Pøevod ze&nbsp;stávající mírnì chaotické architektury spoèívající v&nbsp;systému pojmenování
jednotlivıch funkcí pracujících nad spoustou globálních objektù trval
zhruba šest tıdnù. Další mìsíc trvaly pokusy o zachování kompatibility s Internet Explorerem,
které jsem však nakonec vzal s nadìjí, e jednou bude i tento prohlíeè pracovat podle standardù.

</p><p>Od té doby se projekt dostal do hratelné podoby, ovšem není ještì kompletní.
Zejména chybí pùvodní konec hry, kdy máte pøijít za sleènou Mimi s&nbsp;nashromádìnım bohatstvím
a ta pøijme nabídku k sòatku. Nicménì úèel hry v této práci není (jenom) poskytnout ètenáøùm
zábavu, ale pøedvést monosti JavaScriptu, kterıto úkol plní dobøe ji v souèasném stavu.

</p>


</div>
			</div>
			<div>
				<a name="k-b-1-2"></a>
				<h4>B.1.2. Koncept hry</h4>
				<div><!-- MinerJS / Koncept hry -->

<p>Koncept hry je pøebrán z&nbsp;pùvodní hry Miner VGA od H. Stillese.
Pochopitelnì byl lehce modifikován podle pøedstav autora,
ale princip zùstal stejnı.

</p><p>Jedná se o&nbsp;jednoduchou logicko-ekonomickou strategii, ve&nbsp;které má&nbsp;hráè za&nbsp;úkol
v&nbsp;roli horníka hledat, tìit a&nbsp;zpenìovat rudy vzácnıch kovù.
V&nbsp;tom je&nbsp;mono si&nbsp;pomoci uitím
nìkolika druhù nástrojù, které&nbsp;se dají koupit v&nbsp;místním obchodì u&nbsp;Igora.
Horník mùe bıt pøi nehodách v&nbsp;dole také zranìn a&nbsp;mùe i&nbsp;zemøít.
Zranìní je mono léèit v&nbsp;Nemocnici svatého Døeváka.

</p><p>Celá vaše snaha vede k jedinému cíli hry:
Oenit se (ano, jste horník &ndash; mu) se sleènou Mimi, která, slušnì øeèeno, provozuje místní saloon.
Mimi je ale nároèná ena a&nbsp;jako podmínku si&nbsp;stanovila vaše bohatství - a&nbsp;to pomìrnì vysoké,
navíc chce prsten s diamantem.
A tak ne dosáhnete vytoueného cíle, vytìíte skoro celı dùl.

</p><p>Bohuel jsem nemìl k dispozici zdrojové kódy pùvodní hry,
proto neznám hodnoty koeficientù, které ovlivòují prakticky vše - 
frekvenci vıskytù rud a&nbsp;jevù v&nbsp;podzemí, míru zranìní pøi nehodách  v&nbsp;dole,
opotøebení a&nbsp;vıdr nástrojù, nákupní cenu nástrojù, prodejní cenu rud,
vıši úvìru v&nbsp;bance, riziko nakaení chorobou v&nbsp;saloonu,
cenu léèby atd. atd. Ale právì tyto parametry ve vısledku urèují,
nakolik bude hra hratelná, jinımi slovy jestli bude napínavá
a bude pro hráèe znamenat vızvu, ani by se však stala pøíliš sloitou.
Proto nechávám tyto parametry ještì otevøené a&nbsp;urèitì budou ještì upravovány.
Ostatnì mùe si&nbsp;je upravit kdokoliv - jsou v&nbsp;souborech <code>inc.konstanty.js</code>,
<code>inc.panacek.js</code> a&nbsp;<code>inc.predmety.js</code>.

</p><p>Tìba probíhá následovnì:
Horník s vhodnımi optickodiagnostickımi nástroji (louè, lampa, svítilna)
prochází dolem a&nbsp;ohledává horniny. Kdy bude zkoumat dostateènì,
obèas zjistí, e na urèitém místì je nìjaká anomálie. Proto obchází kolem,
prohlíí, a zjistí, co na daném místì zìmì ukrıvá. Mùe narazit na zlatou ílu,
ale také se mùe jednat o&nbsp;podzemní pramen, a&nbsp;pokus o&nbsp;vytìení tohoto místa
mùe skonèit špatnì. Ještì nebezpeènìjší je zával. Nìkde je konzistence pùdy
narušena, a&nbsp;provedení tìby v&nbsp;tomto místì mùe narušit statiku dolu.
Vzácnı, ale o&nbsp;to osudovìjší bıvá vıskyt methanu. Vyskytuje se hlavnì ve spodních vrstvách.
Dá se proti nìmu se chránit - nepouívat otevøenı oheò.
Detekovat se dá chemickou sondou nebo klecí  kanárkem.
(V dobì psaní práce teprve èeká na implementaci.)

</p>
</div>
			</div>
			<div>
				<a name="k-b-1-3"></a>
				<h4>B.1.3. Zvolené prostøedky pro zobrazení</h4>
				<div><!-- MinerJS / Zvolené prostøedky pro zobrazení -->

<p>Monosti vytváøení grafiky prostøedky, které má JavaScript v prohlíeèích
k dispozici, jsou velmi omezené (pokud nepoèítáme formát SVG, které je však stále ve vıvoji
a není v prohlíeèích zatím rozšíøen - viz kapitola <a href="#k-a-3-9">Provázanost JavaScriptu s SVG</a>).
Této høe to však nevadí, protoe je (stejnì jako púvodní hra) vykreslována technikou "sprajtù" (angl. sprite).
</p>

<a href="k-b-1-3-sprajty"></a>
<h5>"Sprajty"</h5>

<div style="float: left; margin: 1ex 2ex 1em 0; border: 1px solid black; padding: 1ex; background: #AD5200;
	font-size: 15pt; font-weight: bold; vertical-align: bottom;">
<div>
<img src="img/miner/minerr.gif" alt="horník" width="32" height="48" />
 + <img src="img/miner/zlato2.gif" alt="zlato" width="32" height="48" />
= <img src="img/miner/_dolar.gif" alt="dolary" width="32" height="48" />
</div>
<div>
<img src="img/miner/minerr.gif" alt="horník" width="32" height="48" />
 + <img src="img/miner/zaval.gif" alt="zával" width="32" height="48" />
= <img src="img/miner/minerr_gray.gif" alt="mrtvej horník" width="32" height="48" />
</div>
</div>

<p>Sprite je obrázek, obvykle malı a rastrovı, kterı se následnì opakovanì pouívá.
Tato technika byla pouívána v prvním období grafickıch dvourozmìrnıch her (Prince&nbsp;of&nbsp;Persia, Ugh), zejména logickıch (Sokoban),
i&nbsp;pseudo-trojrozmìrnıch (Dungeon&nbsp;Master, Eye&nbsp;of the&nbsp;beholder, Hostages),
Je moné&nbsp;ji s&nbsp;vıhodou pouít i&nbsp;k&nbsp;vykreslování izometrické grafiky
(X-COM: Enemy&nbsp;Unknown, X-COM: Terror from the&nbsp;Deep, Transport&nbsp;Tycoon,
Settlers, Civilization, Alpha&nbsp;Centauri, Command&nbsp;and&nbsp;Conquer, ...).
Ponìkud nehezky pak byly sprajty zasazeny i&nbsp;do&nbsp;3D&nbsp;her (Escape from the&nbsp;Castle&nbsp;Wolfenstein,
Doom, Duke&nbsp;Nukem&nbsp;3D, ...),
ovšem jakoukoliv lepší prezentaci objektù (postav, pøedmìtù, kulis) by tehdejší grafickı vıkon poèítaèù nezvládl.
Dodnes se sprajty pouívají na ploché rovné objekty malé tloušky na jiné ploše - papír na stole, oprıskání zdi, stopy,
prùstøel v&nbsp;oknì apod., nebo vzdálené objekty.
Moderní postupy je však dokáou do&nbsp;3D&nbsp;grafiky zaèlenit nenásilnì a&nbsp;pøirozenì.

</p><p>Ve høe Miner JS jsou sprajty pouity zpùsobem stejnım jako prvních grafickıch logickıch hrách - 
jedná se ze znaèné èásti o obrázky velikosti 16 x 24 pixelù poskládané vedle sebe do HTML tabulky,
v ní kadá buòka obsahuje jeden obrázek jako pozadí a jeden jako obsah.
Tím dostáváme docela ucházející vyjadøovací prostøedky - kdy vezmeme v úvahu, e máme k dispozici
ještì barvu pozadí buòky, mùeme bez dalších úprav tabulky sloit do jedné buòky hned tøi vrstvy
nesoucí nìjakou informaci.

</p><p>Pro úplnost - horník je také sprajt, i vıtah je sprajt, ptáci létající po obloze jsou sprajty,
mraky se skládají ze dvou nebo tøí sprajtù, ikony nástrojù jsou sprajty. Kaktus a WC jsou také sprajty
a i domy jsou sloeny ze sprajtù. Jak je vidìt, hra je sprajtù opravdu plná.
</p>



<a name="k-b-1-3-rozvrzeni_dokumentu"></a>
<h5>Rozvrení dokumentu</h5>
<p>Aplikace je v podstatì jen sloitı HTML dokument. To nám dává v podstatì dvì monosti jeho rozvrení:
Pomocí tabulky nebo dynamickım absolutním polohováním s pouitím JavaScriptu a CSS.
</p>

<img src="img/miner/mysnap.gif" alt="" width="815" height="336" border="0" class="border" style="margin-top: 1ex;" />

<p>Pùvodnì byla pouita tabulka, ovšem toto øešení se ukázalo bıt jako neflexibilní a
mìlo pøíliš mnoho neádoucích vedlejších efektù. Uprostøed vıvoje jsem se rozhodl upøednostnit
absolutní polohování a rozèlenit dokument do hierarchie blokovıch elementù.

</p><p>Samotná struktura dokumentu je velice prostá, jeliko veškerá rozmanitost a sloitost
byla kvùli vìtší flexibilitì pøenesena na JavaScript. Dokument tedy obsahuje jen nìkolik
blokovıch elementù a jednu dvoudílnou tabulku - viz soubor <code>index.html</code>:
</p>

<pre><code class="html block default_mode_code small_code"
>&lt;body&gt;

<span class="cmt">&lt;!-- Uvítací grafika - zmizí po naètení a pøípravì skriptù. --&gt;</span>
&lt;div id="splashscreen"&gt;<span class="cmt">&lt;!-- ... --&gt;</span>&lt;/div&gt;

<span class="cmt">&lt;!-- Logo vlevo nahoøe --&gt;</span>
&lt;div id="logo"&gt;<span class="cmt">&lt;!-- ... --&gt;</span>&lt;/div&gt;

&lt;div id="playground"&gt;
<span class="cmt">&lt;!-- Mraky --&gt;</span>
&lt;div id="mrak1"&gt;&lt;/div&gt;
&lt;div id="mrak2"&gt;&lt;/div&gt;
&lt;div id="ptak1"&gt;<span class="cmt">&lt;!-- ... --&gt;</span>&lt;/div&gt;
<span class="cmt">&lt;!-- Horník --&gt;</span>
&lt;div id="miner"&gt;&lt;img id="minerimg" src="img/minerr.gif"
    width="16" height="24" alt="" /&gt;&lt;/div&gt;
<span class="cmt">&lt;!-- Vıtah --&gt;</span>
&lt;div id="vytah"&gt;&lt;img id="vytahimg" src="img/vytah.gif"
    width="16" height="36" alt="" /&gt;&lt;/div&gt;

<span class="cmt">&lt;!-- Tabulka se samotnou hrou --&gt;</span>
&lt;table border="0" cellpadding="0" cellspacing="0" id="gametable"&gt;
  <span class="cmt">&lt;!-- Svìt nad zemí a zemì --&gt;</span>
  &lt;tbody id="world"&gt;  &lt;/tbody&gt;
  <span class="cmt">&lt;!-- Podzemí --&gt;</span>
  &lt;tbody id="underground"&gt;  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

<span class="cmt">&lt;!-- Oblast s informacemi --&gt;</span>
&lt;div id="infotable"&gt;<span class="cmt">&lt;!-- ... --&gt;</span>&lt;/div&gt;

&lt;/body&gt;
</code></pre>

<p>Zbytek dokumentu tvoøí rùzné funkèní elementy jako metainformace nebo naèítání skriptù a CSS souborù.
Vnitøek tabulky s herním prostorem (kterı by jinak zabral nìkolik tisíc øádkù HTML kódu) je generován JavaScriptem.
</p>


<a name="k-b-1-3-budovy"></a>
<h5>Budovy</h5>
<p>Pøi vstupu do budovy se otevøe nové okno prohlíeèe s minimem standartních prvkù okna.
V tomto oknì je naèten HTML dokument pøíslušné budovy a následnì jsou JavaScriptem
urèité oblasti vyplnìny podle aktuálního stavu hry. Okna budov se ovládají
individuálními sadami kláves, které jsou vyznaèeny pøímo v oknì. Na obrázku je okno pro banku
s HTML dokumentem <code class="file">budova.banka.html</code> (v tištìné verzi je v pøíloze).
</p>
<img src="img/screenshot_miner_banka.gif" alt="" width="756" height="599" id="screenshot_miner_banka" />


<h5>Nekompatibilita s prohlíeèem Internet Explorer</h5>
<p>Jeliko vırobce nejrozšíøenìjšího prohlíeèe Internet Explorer, firma Microsoft, ji pøed nìkolika lety
rezignovala na jeho další vıvoj, a to ve stavu, kdy je IE velmi nekompatibilní se standardy,
rozhodl jsem se vyvíjet hru Miner podle standardù s vìdomím monosti, e Internet Explorer 7 a po nìm jakákoliv
další verze nikdy nebude postupovat podle standardù a hra v nìm tedy nemusí fungovat.

</p><p>Vıvoj hry s cílem vyhovìt nekorektnímu chování a pøizpùsobit kód návrhovım chybám IE
by vedl k paralelnímu ošetøování nejrùznìjších aspektù na mnoha místech kódu a vıvoj by
se stal mnohem nároènìjším jak èasovì, tak sloitostí. Vzhledem k tomu, e není jisté,
jakım smìrem se bude další vıvoj IE ubírat, není zaruèeno, ale ani vylouèeno, e hra bude
v budoucnosti pøepracována tak, aby fungovala i v tomto prohlíeèi.
</p>
</div>
			</div>
			<div>
				<a name="k-b-1-4"></a>
				<h4>B.1.4. Dekompozice</h4>
				<div><!-- MinerJS / Dekompozice -->

<h5>Prùbìh dekompozice</h5>

<p>Jestlie jste èetli kapitolu <a href="#k-b-1-1">Historie vıvoje hry</a>,
víte, e vısledná dekompozice hry není vısledkem seance nad sofistikovanım UML grafem,
nıbr vznikala víceménì ivelnì tak, jak jsem èetl knihu
<a href="#zdroj_javascript">JavaScript - kompletní prùvodce</a> a bìhem ètení
zaèínal chápat koncepci JavaScriptu a uvìdomovat si jeho monosti.
Pøesto si troufám tvrdit, e je docela dobrá, protoe ji pùvodní dekompozice
èlenila hru na oddìlené logické celky, pouze byla realizována pøíliš primitivními
metodami - nìco na zpùsob programování sloitıch programù v jazyce C (nikoliv C++).

</p><p>Pokud má nìkdo zájem vidìt vskutku a nevkusnou sloitost takového stylu programování,
nech se podívá do zdrojovıch kódù projektù jako
<a href="http://www.php.net/">PHP</a>, <a href="http://httpd.apache.org/">Apache HTTP Server</a>
nebo tøeba <a href="http://expat.sourceforge.net/">Expat XML Parser</a>,
které jsou z dùvodu maximální pøenositelnosti psány vıhradnì v jazyce C.
Monost vıvoje projektu takovıch rozmìrù potom stojí a padá na dokonalé organizaci
jmen funkcí, souborù s kódem, na rozsáhlé automatizaci a na mnoha dalších podpùrnıch
organizaèních nástrojích a celkovì je jejich vıvoj velice nároènı.

</p><p>Nicménì i v takovém kódu se samozøejmì dá realizovat dekompozice - místo
objektù se vytváøejí obyèejné struktury, místo metod tøíd se vytváøejí funkce pojmenované
stylem <code>Tøída_JménoMetody()</code> a jako první argument se všem funkcím pøedává
struktura, nad ní se má pracovat.
Právì takovım zpùsobem vypadal kód hry bìhem vıvoje pøi <a href="#k-b-1-1">prvním, druhém a tøetím pokusu</a>.

</p><p>Ve ètvrtém pokusu u byl kód kompletnì pøepsán do objektové podoby.
Leckde se objevil problém, e stávající dekompozice nešla pøevést do objektové podoby.
V takovıch situacích došlo k razantním zmìnám ve struktuøe, které byly provádìny èistì
podle jednoduchıch principù OOP. Vısledkem je pomìrnì
pøehledná a efektivní struktura.
</p>






<h5>Vnitøní struktura aplikace</h5>

<h6>Tøída <code>cGame</code> a její jediná instance <code>window.game</code></h6>

<p>Nejvyšší objekt aplikace je jedinı objekt tøídy <code>cGame</code>, která je uloena v souboru <code>inc.game.js</code>:
</p>

<pre><code class="js block"
><span class="cmb">/* class cGame - hlavni objekt obsahujici vse */</span>
<span class="k">function</span> cGame(doc){
  <span class="k">this</span>.doc = doc;
  <span class="k">this</span>.table = doc.all[<span class="s">'gametable'</span>];
  
  <span class="cml">// umisti panacka //</span>
  <span class="k">this</span>.panacek = <span class="k">new</span> cPanacek(<span class="k">this</span>, <span class="k">this</span>.doc.all.miner,
     CELLS_HORIZ-<span class="n">3</span>, WORLD_HEI-<span class="n">2</span>);
  <span class="cml">// umisti vytah   //</span>
  <span class="k">this</span>.vytah = <span class="k">new</span> cVytah(<span class="k">this</span>.doc.all.vytah, CELLS_HORIZ-<span class="n">1</span>);
  <span class="k">this</span>.world = <span class="k">new</span> cWorld();
  <span class="k">this</span>.ground = <span class="k">new</span> cGround();
  
  <span class="k">this</span>.sTypedString = <span class="s">""</span>;
}
cGame.<span class="k2">prototype</span>.panacek;
cGame.<span class="k2">prototype</span>.vytah;
cGame.<span class="k2">prototype</span>.world;
cGame.<span class="k2">prototype</span>.ground;
cGame.<span class="k2">prototype</span>.table;
cGame.<span class="k2">prototype</span>.sTypedString;

<span class="cml">// "pointer" to set of strings (lang. mutations) in cLang[...].str</span>
cGame.str;
<span class="cml">// "pointer" to set of game settings const. in cSettings[...].konst</span>
cGame.konst;
</code></pre>

<p>Hned v této tøídì si mùete všimnout jedné anomálie dané historickım vıvojem kódu.
Pùvodnì byl vyvíjen pro Internet&nbsp;Explorer&nbsp;4.0 podle povrchních znalostí JavaScriptu.
Tím pádem byla hojnì uívána kolekce <code>document.all</code>.
Ta prorostla kódem natolik, e místo pracného vyhledávání všech vıskytù
<code>document.all[<i>sElementId</i>]</code> a jejich pøepisování na volání
<code>document.getElementById(<i>sElementId</i>)</code> bylo jednodušší tuto kolekci
vytvoøit i pro prohlíeèe, které ji samy od sebe nevedou.
(Poznámka: Prohlíeèe Mozilla od vnitøní verze 1.8 kolekce <code>all</code> z dùvodu kompatibility podporují.)
</p>

<pre><code class="js block"
><span class="k">if</span>(!document.all){
  document.all = <span class="k">new</span> cElementsById(document, <span class="s">"#all#"</span>);
}
</code></pre>

<p>Toto volání vytvoøí novı objekt tøídy <code>cElementsById</code>,
která si v konstruktoru "vytahá" reference na všechny elementy v dokumentu s nastavenım ID.
To je realizováno buï rozhraním <i>Traversal&nbsp;2.0</i> nebo "ruèním" rekurzivním projitím celého stromu dokumentu.
Tøída <code>cElementsById</code> je v souboru <code class="file">inc.elements.js</code>.

</p><p>V objektu <code>cGame</code> si dále ukládáme referenci na objekt <code>window.document</code>.
Naskıtá se otázka po smyslu, kdy objekt <code>document</code> je vdy k dispozici.
Pøesvìdèivá odpovìï neexistuje - ale je návrhovì èistší v metodách pracovat s objektem odkazovanım vlastností aktuálního objektu
ne ho lovit odnìkud z globálního prostoru. Navíc v pøípadì implementace hry napø. v Mozilla Frameworku
by u objekt <code>window.document</code> vdy dostupnı bıt nemusel.

</p><p>Dále jsou zde objekty vıtahu a panáèka. Obìma do konstruktoru dodáme referenci na jejich absolutnì pozicovanı
element a jejich poèáteèní pozici, panáèkovi navíc dáme referenci na objekt <code>cGame</code>
(aby se pøes nìj mohl odkazovat na další prvky ve høe).

</p><p>Nakonec je v konstruktoru vytvoøení objektù <code>cWorld</code> a <code>cGround</code>.
Z dùvodu optimalizace rozvrstvení zátìe na procesorovı èas se ovšem v jejich konstruktorech nic nedìje.
Odsunutím inicializace nìkolika tisíc poloek se upøednostní vyrenderování grafické podoby stránky
pøed událostí <code>onload</code> a umoní se tak zobrazení takzvaného <i>splashscreen</i>u.
(Poèet bunìk v dole je momentálnì 2250, ovšem to je zkrácená ladící verze, v koneèné verzi by jich mìlo bıt 5000).

</p><p>Poslední poloka <code>sTypedString</code> se tıká cheatù,
take je tajná a uvaluji na ni informaèní embargo&nbsp;:-)

</p><p>Mimo konstruktor inicializujeme prototyp tøídy <code>cGame</code>.
Momentálnì nemá tato inicializace ádnı smysl; mìla by, pokud bych od <code>cGame</code> derivoval
specializovanou tøídu, co jsem kdysi plánoval.

</p><p>Nakonec ještì definujeme promìnné tøídy, tedy "statické promìnné". V nich budou
pozdìji pøi inicializaci uloeny objekty s lokalizovanımi texty a zvolená konfigurace hry.
</p>




<h6>Tøída <code>cWorldCell</code></h6>

<p>Tøída <code>cWorldCell</code> je jednoduchá. Svìt nad zemí je víceménì statickı,
proto ho není tøeba ve struktuøe objektù nijak rozvádìt.
Jediné, co nás nahoøe zajímá, jsou dveøe do budov, klandr a kaktus (a samozøejmì WC).
Tyto buòky odlišíme vlastností <code>type</code>.
Jednotlivé dveøe odlišíme vlastností <code>dvereid</code>.</p>
<pre><code class="js block small_icon"
><span class="k">function</span> cWorldCell(type, dvereid){
  <span class="k">this</span>.type = type;
  <span class="k">this</span>.dvereid = dvereid;
}
</code></pre>
<p>Krásnı pøípad aplikace dìdiènosti:
Mohli bychom vytvoøit tøídu <code>cWorldCellDoor</code> a tøídì <code>cWorldCell</code>
odebrat vlastnost <code>dvereid</code>, jeliko ta se netıká všech typù bunìk.
Ovšem v kódu tuto høíèku nenajdete - jednalo by se o zbyteènou a bezúèelnou komplikaci.
I v OOP je tøeba znát rozumné meze.


<h6>Tøída <code>cWorld</code></h6>
</p><p>Tøída <code>cWorld</code> je docela jednoduchá - po stránce vlastností 
obsahuje tzv. mapu, co je dvourozmìrné pole objektù <code>cWorldCell</code>,
a referenci na <code>HTMLTableSectionElement</code> - neboli horní <code class="htmll">&lt;tbody&gt;</code>.
Obsahuje ètyøi metody, pouité pøi inicializaci aplikace v metodì <code>window.OnLoad()</code>.
</p>
<ul> <li>Metoda <code>Init()</code> pouze vytváøí datovou strukturu pro následující kroky inicializace ("naPleskání()" sprajtù).
</li><li>Metody <code>PleskniBarak()</code>, <code>PleskniSprite()</code> a <code>PleskniDvere()</code>
obstarávají vloení patøiènıch sprajtù do správnıch míst tabulky.
</li></ul>



<h6>Tøída <code>cGroundCell</code></h6>
<p>Tøída <code>cGroundCell</code> reprezentuje buòku pod povrchem.
Jeliko právì kolem tìchto bunìk se celá hra toèí, je o poznání sloitìjší.

</p><p>

</p>

<pre><code class="js block small_icon"
><span class="k">function</span> cGroundCell(puda, type, kolik){
  <span class="k">this</span>.puda      = puda;        <span class="cml">// typ pudy</span>
  <span class="k">this</span>.type      = type;        <span class="cml">// typ obsahu</span>
  <span class="k">this</span>.kolik     = kolik;       <span class="cml">// kolik je v bunce jednotek obsahu</span>

  <span class="k">var</span> kryti = (type==g_sachta) ? <span class="n">4</span>
     : <span class="f">Math</span>.floor(<span class="f">Math</span>.random()*<span class="n">1000</span>) % <span class="n">4</span>;
  <span class="cml">// kryti bunky, tedy co bude zobrazeno, dokud se neodkryje</span>
  <span class="k">this</span>.kryti = kryti;
  <span class="cml">// Dale si uz kryti nebudeme vsimat (krome cGround::RedrawCell())</span>
  
  <span class="k">this</span>.vytezeno  = <span class="l">false</span>;       <span class="cml">// bool   - vytezeno                 </span>
  <span class="cml">//this.odkryto   = 0.0;</span>
  <span class="k">var</span> r = <span class="f">Math</span>.random();
  <span class="cml">// double - postup odkryvani; generuje se nahodne od -3 do 0</span>
  <span class="k">this</span>.odkryto   = <span class="n">-3</span> * (r*r*r);
  <span class="k">this</span>.zatopeno  = <span class="l">false</span>;       <span class="cml">// bool   - jestli je to zatopeny</span>
  <span class="k">this</span>.methan    = <span class="l">false</span>;       <span class="cml">// bool   - jestli je v bunce methan</span>
  <span class="k">this</span>.vyztuzeno = (type == g_sachta) ? <span class="l">false</span> : <span class="l">false</span>;
  
  <span class="k">if</span>(<span class="k">this</span>.puda == g_voda){
    <span class="k">this</span>.puda = g_normal; <span class="k">this</span>.zatopeno = <span class="l">true</span>;
  }
}
</code></pre>

<p>Vysvìtlíme si jednotlivé vlastnosti:</p>

<pre><code class="js block small_icon"
><span class="k">this</span>.puda      = puda;        <span class="cml">// typ pudy</span>
</code></pre>
<p>Urèuje typ pùdy, napø. normální, pískovec, skála, jílovitá (tuhá), pramen, šachta atd.
Jedná se o èíslo. Na základì této hodnoty hra reaguje pøi pokusu o tìbu.
Podle ní se také vybere správnı sprajt na pozadí.
</p>

<pre><code class="js block small_icon"
><span class="k">this</span>.type      = type;        <span class="cml">// typ obsahu</span>
</code></pre>
<p>Urèuje obsah pùdy (èi spíše buòky): nic, platina, zlato, støíbro, mìï, uhlí, štìstí, dynamit, drahokam, prsten.
Jedná se o èíslo. Na základì této hodnoty hra reaguje pøi úspìšném pokusu o tìbu.
Podle ní se také vybere správnı sprajt na popøedí.
</p>

<pre><code class="js block small_icon"
><span class="k">var</span> kryti = (type == g_sachta) ? <span class="n">4</span>
     : <span class="f">Math</span>.floor(<span class="f">Math</span>.random() * <span class="n">1000</span>) % <span class="n">4</span>;
<span class="k">this</span>.kryti = kryti;           <span class="cml">// kryti bunky </span>
</code></pre>
<p>Pøi generování bunìk se náhodnì vybere nìkterı ze sprajtù anonymní pùdy. Kdyby se pouil jen jeden,
vznikl by na ploše neodkryté pùdy nepøíjemnı rušivı vzorek. Takto se vzorek rozptılí.
</p>

<pre><code class="js block small_icon"
><span class="k">var</span> r = <span class="f">Math</span>.random();
<span class="cml">// double - postup odkryvani; generuje se nahodne od -3 do 0</span>
<span class="k">this</span>.odkryto   = <span class="n">-3</span> * (r*r*r);
</code></pre>
<p>Urèuje postup odkrıvání. Kdy prochází horník dolem, prozkoumává okolní buòky. To je realizováno zvyšováním této hodnoty:
</p>
<ul> <li>Kdy pøekroèí mez <code>KOEF_ODKRYTOPUDA</code>, je odhalen typ pùdy.
</li><li>Kdy pøekroèí mez <code>KOEF_ODKRYTOPUL</code>, je odhaleno, e v buòce nìco je.
</li><li>Kdy pøekroèí mez <code>KOEF_ODKRYTO</code>, je odhalen typ obsahu.
</li></ul>
<p>Meze jsou dány v nastavení (<code>cGame.konst</code>). Vıchozí hodnoty jsou v souboru <code class="file">inc.konstanty.js</code>.</p>

<pre><code class="js block small_icon"
><span class="cml">// Koeficient odkryvani pudy</span>
<span class="k">var</span> KOEF_ODKRYTO     = <span class="n">4.0</span>, <span class="cml">// Odkryto vse - typ pudy i typ obsahu</span>
    KOEF_ODKRYTOPUL  = <span class="n">2.0</span>, <span class="cml">// Odkryt typ pudy a jestli ma obsah</span>
    KOEF_ODKRYTOPUDA = <span class="n">1.0</span>; <span class="cml">// Odkryt typ pudy</span>
</code></pre>

<p>Následují u jen logické hodnoty urèující další hodnoty buòky:
</p>

<pre><code class="js block small_icon"
><span class="k">this</span>.vytezeno  = <span class="l">false</span>;       <span class="cml">// bool   - vytezeno                 </span>
<span class="k">this</span>.zatopeno  = <span class="l">false</span>;       <span class="cml">// bool   - jestli je to zatopeny    </span>
<span class="k">this</span>.methan    = <span class="l">false</span>;       <span class="cml">// bool   - jestli je v bunce methan </span>
<span class="k">this</span>.vyztuzeno = (type == g_sachta) ? <span class="l">false</span> : <span class="l">false</span>;
</code></pre>

<p>Tøída disponuje mnostvím metod pro manipulaci s objektem buòky.</p>



<h6>Tøída <code>cGround</code></h6>
<p>Tøída <code>cGround</code> podobnì jako tøída <code>cWorld</code> obsahuje tzv. mapu,
co je dvourozmìrné pole objektù <code>cGroundCell</code>,
a referenci na <code>HTMLTableSectionElement</code> - neboli dolní <code class="htmll">&lt;tbody&gt;</code>.

</p><p>Dále obsahuje metodu <code>Init()</code> pouitou pøi inicializaci aplikace v metodì <code>window.OnLoad()</code>,
a mnoství metod pro manipulaci s jednotlivımi buòkami. Z nich vysvìtlíme jen jednu:

</p><p>Metoda <code>RedrawCell(y,x)</code> upraví CSS vlastnosti buòky tabulky na zadanıch souøadnicích
podle objektu buòky na tìche souøadnicích v mapì. Jedná se o stìejní zobrazovací funkci.

</p>




<h6>Horník - tøída <code>cPanacek</code></h6>
<p>Tøída <code>cPanacek</code> reprezentuje horníka. Názvy jejích vlastností vysvìtluje jejich vıznam,
proto postaèí vıpis kódu konstruktoru:
</p>

<pre><code class="js block small_icon"
><span class="k">function</span> cPanacek(game, div, x,y){
  <span class="k">this</span>.game = game;
  <span class="k">this</span>.div = div;
  <span class="k">this</span>.img = bMSIE ? div.all.minerimg : div.firstChild;
  <span class="k">this</span>.x = x;               <span class="cml">// x position</span>
  <span class="k">this</span>.y = y;               <span class="cml">// y position</span>
  <span class="k">this</span>.dir = <span class="n">1</span>;             <span class="cml">// -1 left, 1 right</span>
  <span class="k">this</span>.iPohyby = <span class="n">0</span>;
  <span class="k">this</span>.vevytahu = <span class="n">0</span>;
  <span class="k">this</span>.sGroundBgCol = COLOR_GROUND_BGDARK;
  
  <span class="cml">// objekt inventare s metodami atd.</span>
  <span class="k">this</span>.inv = <span class="k">new</span> cInventar();
  <span class="cml">// Objekt cPredmet z this.inv, ktery je pripraven na pristi pohyb.</span>
  <span class="k">this</span>.pripraveno = <span class="l">null</span>;
  
  <span class="k">this</span>.penize = PAN_START_PENIZE; <span class="cml">// stav na uctu; zahrnuje dluh </span>
  <span class="k">this</span>.debt   = PAN_START_DLUH;   <span class="cml">// dluh v bance; limit MAX_DEBT</span>
  <span class="k">this</span>.zdravi = PAN_START_ZDRAVI; <span class="cml">// zdravi <= 0 -> smrt;  max. 100</span>
  <span class="k">this</span>.stit   = <span class="n">0</span>;
  <span class="k">this</span>.pt     = <span class="n">0</span>;   <span class="cml">// platina</span>
  <span class="k">this</span>.au     = <span class="n">0</span>;   <span class="cml">// zlato</span>
  <span class="k">this</span>.ag     = <span class="n">0</span>;   <span class="cml">// stribro</span>
  <span class="k">this</span>.cu     = <span class="n">0</span>;   <span class="cml">// med</span>
  <span class="k">this</span>.co     = <span class="n">0</span>;   <span class="cml">// uhli</span>
  <span class="k">this</span>.lu     = <span class="n">0</span>;   <span class="cml">// stesti (luck)</span>
  
  <span class="k">this</span>.casNaZachode  = <span class="k">new</span> <span class="f">Date</span>();
  <span class="k">this</span>.casZmenaKurzu = <span class="k">new</span> <span class="f">Date</span>();
  <span class="k">this</span>.cizinci       = <span class="l">false</span>;
  
  <span class="k">this</span>.aOdkryvDistrib = <span class="k">new</span> <span class="f">Array</span>();
  <span class="k">var</span> aOD = <span class="k">this</span>.aOdkryvDistrib;
  aOD[<span class="n">-2</span>] = <span class="k">new</span> <span class="f">Array</span>();
  aOD[<span class="n">-1</span>] = <span class="k">new</span> <span class="f">Array</span>();
  aOD[<span class="n"> 0</span>] = <span class="k">new</span> <span class="f">Array</span>();
  aOD[<span class="n"> 1</span>] = <span class="k">new</span> <span class="f">Array</span>();
  aOD[<span class="n"> 2</span>] = <span class="k">new</span> <span class="f">Array</span>();
  <span class="k">this</span>.PrepoctiOdkryvKoef();
}
</code></pre>

<p>Za podrobnìjší vysvìtlení stojí vlastnost <code>inv</code>. Ta obsahuje objekt tøídy <code>cInventar</code>
(viz soubor <code class="file">inc.predmety.js</code>).
Pùvodnì byl inventáø realizován jako jednoduché asociativní pole, kde indexem byly identifikátory typù pøedmìtù
a hodnotou byl jejich poèet.
Nutnost další dekompozice na objekt inventáøe a v nìm jednotlivé objekty pøedmìtù, co pøedmìt to objekt tøídy <code>cPredmet</code>,
nastala ve chvíli, kdy jsem chtìl pøiblíit simulaci realitì a kadému nakoupenému pøedmìtu
hlídat trvanlivost (napø. u&nbsp;pumpy zpuchøí gumové tìsnìní) a&nbsp;opotøebení (louè&nbsp;dohoøí),
pøípadnì vypoèítat amortizaci a prodejní cenu v pøípadì zpìtného prodeje Igorovi, místnímu vetešníkovi.
Inventáø bude vysvìtlen dále.



</p><p>Podle zásad OOP mají bıt metody v zásadì dvojího druhu:
<em>Pasivní</em>, tedy takové, které aktivitu pøijímají, a&nbsp;<em>aktivní</em>, které aktivitu provádìjí.
Pasivní obvykle manipulují vlastním objektem.
Aktivní naopak manipulují s jinımi objekty prostøednictvím pasivních jejich metod.

</p><p>Tøída <code>cPanacek</code> má podle tohoto dìlení nejvíce aktivních metod.
Je to logické - pøedstavuje horníka, objekt, jeho prostøednictvím provádí hráè akce.
Naopak vıše vysvìtlená tøída <code>cGround</code> má mnoho pasivních metod, protoe aktivitu prakticky jenom pøijímá
a podle ní aktualizuje svoje datové struktury.
</p><p>
Popisování všech metod tøídy <code>cPanacek</code> by zabralo nìkolik stránek.
Naštìstí jsou vìtšinou celkem jednoduché, a&nbsp;pro pøedstavu o&nbsp;dekompozici postaèí
jejich názvy a&nbsp;parametry:
</p>

<pre><code class="js block small_icon"
>cPanacek.<span class="k2">prototype</span>.HalogenOnOff <span class="o">=</span> <span class="k">function</span><span class="o">(</span>bOn<span class="o">){</span>  <span class="o">}</span>
cPanacek.<span class="k2">prototype</span>.PripravLopatu <span class="o">=</span> <span class="k">function</span><span class="o">(</span><span class="o">){</span>  <span class="o">}</span>
cPanacek.<span class="k2">prototype</span>.PripravKrumpac <span class="o">=</span> <span class="k">function</span><span class="o">(</span><span class="o">){</span>  <span class="o">}</span>
cPanacek.<span class="k2">prototype</span>.PripravVrtak <span class="o">=</span> <span class="k">function</span><span class="o">(</span><span class="o">){</span>  <span class="o">}</span>
cPanacek.<span class="k2">prototype</span>.PripravSbijecku <span class="o">=</span> <span class="k">function</span><span class="o">(</span><span class="o">){</span>  <span class="o">}</span>
cPanacek.<span class="k2">prototype</span>.OdpalDynamit <span class="o">=</span> <span class="k">function</span><span class="o">(</span><span class="o">){</span>  <span class="o">}</span>
cPanacek.<span class="k2">prototype</span>.PripravKbelik <span class="o">=</span> <span class="k">function</span><span class="o">(</span><span class="o">){</span>  <span class="o">}</span>
cPanacek.<span class="k2">prototype</span>.PripravPumpu <span class="o">=</span> <span class="k">function</span><span class="o">(</span><span class="o">){</span>  <span class="o">}</span>

cPanacek.<span class="k2">prototype</span>.GetCellRelative <span class="o">=</span> <span class="k">function</span><span class="o">(</span>dy, dx<span class="o">){</span>  <span class="o">}</span>
<span class="cml">// Prekresli bunku, kde panacek zrovna stoji. //</span>
cPanacek.<span class="k2">prototype</span>.RedrawCellRelative <span class="o">=</span> <span class="k">function</span><span class="o">(</span>dy, dx<span class="o">){</span>  <span class="o">}</span>

<span class="cml">// Prepocita matici na odkryv okoli podle vlastnenych predmetu.</span>
cPanacek.<span class="k2">prototype</span>.PrepoctiOdkryvKoef <span class="o">=</span> <span class="k">function</span><span class="o">(</span><span class="o">){</span>  <span class="o">}</span>
cPanacek.<span class="k2">prototype</span>.Draw <span class="o">=</span> <span class="k">function</span><span class="o">(</span><span class="o">){</span>  <span class="o">}</span>
cPanacek.<span class="k2">prototype</span>.Turn <span class="o">=</span> <span class="k">function</span><span class="o">(</span><span class="o">){</span>  <span class="o">}</span>

<span class="cml">// Posouvani playgroundu </span>
cPanacek.<span class="k2">prototype</span>.Focus <span class="o">=</span> <span class="k">function</span><span class="o">(</span>dy,dx<span class="o">){</span>  <span class="o">}</span>

cPanacek.<span class="k2">prototype</span>.Move <span class="o">=</span> <span class="k">function</span><span class="o">(</span>dx,dy<span class="o">){</span>  <span class="o">}</span>


cPanacek.<span class="k2">prototype</span>.GetCellRelative <span class="o">=</span> <span class="k">function</span><span class="o">(</span>dy,dx<span class="o">){</span>  <span class="o">}</span>

<span class="cml">// Prekresli bunku zadanou relativne od mista, kde panacek stoji</span>
cPanacek.<span class="k2">prototype</span>.RedrawCellRelative <span class="o">=</span> <span class="k">function</span><span class="o">(</span>dy,dx<span class="o">){</span>  <span class="o">}</span>

<span class="cml">// Odkryje bunky okolo panacka</span>
cPanacek.<span class="k2">prototype</span>.OdkryjOkoli <span class="o">=</span> <span class="k">function</span><span class="o">(</span><span class="o">){</span>  <span class="o">}</span>
cPanacek.<span class="k2">prototype</span>.VytezBunkuPudu <span class="o">=</span> <span class="k">function</span><span class="o">(</span>cell<span class="o">){</span>  <span class="o">}</span>
cPanacek.<span class="k2">prototype</span>.VytezBunkuObsah <span class="o">=</span> <span class="k">function</span><span class="o">(</span>cell<span class="o">){</span>  <span class="o">}</span>
cPanacek.<span class="k2">prototype</span>.VytezBunku <span class="o">=</span> <span class="k">function</span><span class="o">(</span>cell<span class="o">){</span>  <span class="o">}</span>
cPanacek.<span class="k2">prototype</span>.ZkusTezitSkalu <span class="o">=</span> <span class="k">function</span><span class="o">(</span>cell<span class="o">){</span>  <span class="o">}</span>
cPanacek.<span class="k2">prototype</span>.ZkusTezitZaval <span class="o">=</span> <span class="k">function</span><span class="o">(</span>cell<span class="o">){</span>  <span class="o">}</span>

cPanacek.<span class="k2">prototype</span>.UberZdraviUprav <span class="o">=</span> <span class="k">function</span><span class="o">(</span>kolik, pricina<span class="o">){</span>  <span class="o">}</span>
cPanacek.<span class="k2">prototype</span>.PridejZdravi <span class="o">=</span> <span class="k">function</span><span class="o">(</span>kolik<span class="o">){ }</span>
cPanacek.<span class="k2">prototype</span>.UberZdravi <span class="o">=</span> <span class="k">function</span><span class="o">(</span>kolik,nomsg<span class="o">){</span>  <span class="o">}</span>

cPanacek.<span class="k2">prototype</span>.TryEnter <span class="o">=</span> <span class="k">function</span><span class="o">(</span><span class="o">){</span>  <span class="o">}</span>
cPanacek.<span class="k2">prototype</span>.VratSe <span class="o">=</span> <span class="k">function</span><span class="o">(</span><span class="o">){</span>  <span class="o">}</span>
cPanacek.<span class="k2">prototype</span>.VratSeZeZachodu <span class="o">=</span> <span class="k">function</span><span class="o">(</span><span class="o">){</span>  <span class="o">}</span>
cPanacek.<span class="k2">prototype</span>.Enter <span class="o">=</span> <span class="k">function</span><span class="o">(</span>dvereid<span class="o">){</span>  <span class="o">}</span>
cPanacek.<span class="k2">prototype</span>.Exit <span class="o">=</span> <span class="k">function</span><span class="o">(</span><span class="o">){</span><span class="o">}</span>

<span class="cml">/****************************
*   Inventar                *
****************************/</span>

<span class="cml">// BuyItem()</span>
cPanacek.<span class="k2">prototype</span>.BuyItem <span class="o">=</span> <span class="k">function</span>(sItemKey, iCena){
  <span class="k">if</span>(<span class="k">this</span>.inv.Pridej(sItemKey)){
    <span class="k">this</span>.UpravPenize(-iCena);
    <span class="k">this</span>.PrepoctiOdkryvKoef();
  }
}

cPanacek.<span class="k2">prototype</span>.PouzijPredmetAZkontroluj <span class="o">=</span> <span class="k">function</span><span class="o">(</span>p<span class="o">){</span>  <span class="o">}</span>
cPanacek.<span class="k2">prototype</span>.UpravPenize <span class="o">=</span> <span class="k">function</span><span class="o">(</span>kolik<span class="o">){</span>  <span class="o">}</span>
cPanacek.<span class="k2">prototype</span>.SynchronizeInfo <span class="o">=</span> <span class="k">function</span><span class="o">(</span><span class="o">){</span>  <span class="o">}</span>
</code></pre>


<!-- ======================================== dodelat /// -->
<h6>Inventáø - tøída <code>cInventar</code></h6>
<p>Tøída <code>cInventar</code> reprezentuje horníkùv inventáø.
Tøída <code>cPanacek</code> má objekt <code>cInventar</code> jako jednu ze svıch vlastností.
</p><p>Má dvì vlastnosti:</p>
<ul> <li><code>predmety</code> je kolekce objektù tøídy <code>cPredmet</code>.
Kadı prvek kolekce pøedstavuje jeden pøedmìt v horníkovì inventáøi.
</li><li><code>pocty</code> je pomocné pole, do kterého se metodou <code>Prepocti()</code>
ukládá poèet pøedmìtù konkrétních typù.
</li></ul>
<p>
</p><p>
</p>

<pre><code class="js block small_icon"
><span class="k">function</span> cInventar<span class="o">(){</span>
  <span class="cml">// Pole predmetu; co prvek, to objekt cPredmet</span>
  <span class="k">this</span>.predmety <span class="o">=</span> <span class="k">new</span> <span class="f">Array</span>();
  <span class="cml">// Asociativni pole: [key] = pocet predmetu</span>
  <span class="k">this</span>.pocty    <span class="o">=</span> <span class="k">new</span> <span class="f">Object</span>();
  <span class="cml">// Inicializujeme pocty na nulu </span>
  <span class="k">this</span>.Prepocti();
<span class="o">}</span>
</code></pre>

<p>Tøída dále obsahuje metody pro manipulaci s inventáøem.
Jejich vıznamy jsou vysvìtleny názvy a komentáøi:
</p>
<pre><code class="js block small_icon"
><span class="cml">// Pøidání pøedmìtu daného typu do inventáøe</span>
cInventar.<span class="k2">prototype</span>.Pridej <span class="o">=</span> <span class="k">function</span><span class="o">(</span>sKey<span class="o">){</span> ... <span class="o">}</span>
<span class="cml">// Odebrání konkrétního objektu pøedmetu z inventáøe</span>
cInventar.<span class="k2">prototype</span>.Odeber <span class="o">=</span> <span class="k">function</span><span class="o">(</span>p<span class="o">){</span> ... <span class="o">}</span>
<span class="cml">// Najde v inventari predmet daneho typu,
// pokud mozno ten s nejmensim poctem zbyvajicich pouziti.</span>
cInventar.<span class="k2">prototype</span>.NajdiNejopotrebovanejsiZapnuty <span class="o">=</span> <span class="k">function</span><span class="o">(){</span> <span class="o">}</span>
<span class="cml">// Prepocita inventar a ulozi pocty</span>
cInventar.<span class="k2">prototype</span>.Prepocti <span class="o">=</span> <span class="k">function</span><span class="o">(</span><span class="o">){</span> ... <span class="o">}</span>
<span class="cml">// Zkontroluje, jestli nejake predmety nedosly</span>
cInventar.<span class="k2">prototype</span>.CheckObsoletness <span class="o">=</span> <span class="k">function</span><span class="o">(</span><span class="o">){</span> ... <span class="o">}</span>
</code></pre>





<h6>Inicializace aplikace</h6>
<p>Inicializace je jednou s nejdùleitìjších pasáí kódu, proto ji probereme krok po kroku.
(Další èásti ji tak podrobnì vysvìtleny nebudou.)
</p>

<code class="js block small_icon"><span class="k">if</span><span class="o">(</span>!isMSIE<span class="o">()){</span> document.readyState <span class="o">=</span> <span class="s">"loaded"</span>; <span class="o">}</span></code>

<p>Prohlíeè IE má uiteènou vlastnost <code>document.readyState</code>, kterou jiné prohlíeèe nemají.
Pro nì ji nasimulujeme, protoe ji vyuzíváme.
</p>

<pre><code class="js block small_icon"
>window.game <span class="o">=</span> <span class="k">new</span> cGame(document);
t <span class="o">=</span> game.table.tBodies;
<span class="k">for</span>(i <span class="k">in</span> t) <span class="k">if</span>(t[i].id <span class="o">==</span> <span class="s">"world"</span>)       w <span class="o">=</span> t[i];
<span class="k">for</span>(i <span class="k">in</span> t) <span class="k">if</span>(t[i].id <span class="o">==</span> <span class="s">"underground"</span>) u <span class="o">=</span> t[i];
</code></pre>
<p>Vytvoøení objektu vıše popsané tøídy <code>cGame</code> a nastavení nìkterıch jeho vlastností.
Smyèka <code>for</code> byla pouita kvùli nekompatibilitì MSIE 6.0 s DOM 1.0.
</p>

<pre><code class="js block small_icon"
>game.world.Init (w, CELLS_HORIZ, WORLD_HEI);
game.ground.Init(u, CELLS_HORIZ, CELLS_VERT);
</code></pre>
<p>Inicializace objektù svìta (baráèky, vstupy do nich, kaktus, WC, ptáci... a "podlaha")
a podsvìtí (jednotlivé buòky - vygenerování obsahu).
</p>

<pre><code class="js block small_icon"
>game.panacek.Draw();
game.vytah.Draw();
</code></pre>
<p>Metody <code>Draw()</code> upravují vlastnosti absolutnì pozicovanıch blokù tak, aby reflektovaly souèasnı stav objektu.
Tedy: Nastaví souøadnice a u panáèka vybere správnı sprajt.
</p>

<pre><code class="js block small_icon"
>game.VytvorTabulku();
</code></pre>
<p>Vytvoøí tabulku s herním plánem. Inicializace metodami <code>Init()</code>
provádí pouze inicializaci objektù; buòky tabulky se vytváøejí a zde.
</p>

<pre><code class="js block small_icon"
>document.all.splashscreen.style.display <span class="o">=</span> <span class="s">"none"</span>;
</code></pre>
<p>Zmizí splashscreen.
</p>

<pre><code class="js block small_icon"
>OnResized();
</code></pre>
<p>Upraví se velikost jednotlivıch oblastí stránky podle velikosti okna.
</p>

<pre><code class="js block small_icon"
>document.all.infotable.style.visibility <span class="o">=</span> <span class="s">"visible"</span>;
document.all.playground.style.visibility <span class="o">=</span> <span class="s">"visible"</span>;
document.all.logo.style.zIndex <span class="o">=</span> <span class="n">15</span>;
</code></pre>
<p>Zobrazí se herní èásti dokumentu - herní plán (tabulka) a tabulka s informacemi, a logo hry (vlevo nahoøe) se dá do popøedí.
</p>

<pre><code class="js block small_icon"
>game.panacek.Focus();
</code></pre>
<p>Pøenese tzv. <i>focus</i> na horníka. Jedná se o ošetøení chyby / vlastnosti prohlíeèe Firefox,
kterı po naètení stránky nastaví focus na první odkaz na stránce a objekt body tak nepøejímá události <code>onkeypress</code>.
</p>

<pre><code class="js block small_icon"
>game.panacek.SynchronizeInfo();
</code></pre>
<p>Synchronizuje texty v informaèní tabulce se stavem objektu horníka.
</p>

<pre><code class="js block small_icon"
>PosliZpravu(<span class="s">"Vítejte v Minerovi! :)"</span>, <span class="s">"white"</span>);
...
</code></pre>
<p>Vypíše uvítací text do informaèní tabulky.
</p>

<pre><code class="js block small_icon"
><span class="k">var</span> windowEventsTarget <span class="o">=</span> (bMSIE ? document.body : window);
windowEventsTarget.onresize <span class="o">=</span> OnResized;
windowEventsTarget.onhelp <span class="o">=</span> <span class="k">function</span><span class="o">(</span><span class="o">){</span> ... <span class="o">}</span>;
windowEventsTarget.onkeypress <span class="o">=</span> OnKeyPressed;
</code></pre>
<p>Ach ta nekompatibilita. Kadı prohlíeè registruje handler událostí na jiném objektu.
<code>onresize</code> obslouí funkce <code>OnResized</code>, ta ji byla zmínìna.
<code>onhelp</code> se vyvolá pøi stisku klávesy <code>F1</code>; hra reaguje vstupem do infocentra.
<code>onkeypress</code> je nejdùleitìjší handler - zachytává stisky kláves.
</p>

<pre><code class="js block small_icon"
><span class="k">if</span><span class="o">(</span>!bMSIE<span class="o">){</span>
  document.readyState <span class="o">=</span> <span class="s">"complete"</span>;
<span class="o">}</span>
window.defaultStatus <span class="o">=</span> window.status <span class="o">=</span> GAME_NAME +<span class="s">" "</span>+ GAME_VERSION;
</code></pre>
<p>Nejprve opìt simulace vlastnosti <code>readyState</code>,
potom nastavení textu do stavového øádku.
</p>

<pre><code class="js block small_icon"
>setTimeout(<span class="s">"OnAnimateMrak()"</span>, <span class="n">500</span>);
setTimeout(<span class="s">"OnCheckInventory()"</span>, CAS_INVENTORY_CHECK_DELAY_MS);
</code></pre>
<p>Na úpném konci inicializace jsou spouštìny cyklicky se opakující èinnosti:
Zaprvé animace mraku (pluje po obloze) a zadruhé (mnohem dùleitìjší) kontrola inventáøe,
jestli nìkterému pøedmìtu nedošla ivotnost èi baterie.
</p>

<pre><code class="js block small_icon"
>window.PosliZpravu <span class="o">=</span> <span class="k">function</span><span class="o">(</span>str, clss<span class="o">){</span>
  PosliZpravuDoOkna(window, str, clss);
<span class="o">}</span>
window.PosliZpravuArg <span class="o">=</span> <span class="k">function</span><span class="o">(</span>str, arg, clss<span class="o">){</span>
  PosliZpravuDoOkna(window, UCFirst(str.replace(<span class="s">"%1"</span>, arg)), clss);
<span class="o">}</span>
</code></pre>
<p>Nakonec ještì vysvìtlení k funkcím <code>PosliZpravu()</code> a <code>PosliZpravuArg()</code>:
Jedná se o jednotné "API okna". Nìkteré metody objektu panáèka spoléhají na to, e kadé okno,
ve kterém jsou volány, má definované tyto funkce, jejich prostøednictvím vypisují zprávy pro uivatele.
</p>
</div>
			</div>
			<!-- <div>
				<a name="k-b-1-5"></a>
				<h4>Realizace jednotlivıch èástí</h4>
				<div><!- -#include file="B-1-5.inc.html" - -></div>
			</div>
			<div>
				<a name="k-b-1-6"></a>
				<h4>Testování</h4>
				<div><!- -#include file="B-1-6.inc.html" - -></div>
			</div>
			<div>
				<h4>[Stanovení ceny a prodej :) ]</h4>
				<div></div>
			</div> -->
			<div>
				<a name="k-b-1-8"></a>
				<h4>B.1.5. Další monosti</h4>
				<div><!-- MinerJS / Další monosti -->

<p>Hlavním cílem praktické èásti bylo pøedvést v praxi monosti jazyka JavaScript,
popisované v teoretickém pojednání. Za tímto úèelem ji byly implementovány tyto prvky:
</p>

<ul> <li>hra samotná
</li><li>ukládání stavu hry do cookies
</li><li>monost lokalizace hry &ndash; pøeklad do jinıch jazykù
</li><li>monost zvolit jinou obtínost hry vıbìrem jiné sady konstant
</li></ul>

<p>Potenciál hry pro implementaci dalších zajímavostí tím ale není zdaleka vyèerpán.
Co vše by se ještì dalo se stávajícím projektem provést:
</p>

<ul> <li>vytvoøit ekonomické prostøedí, které by simulovalo dìní na trhu s komoditami (rudami)
</li><li>automatizace chování panáèka &ndash; implementace neuronové sítì
</li><li>místo v prohlíeèi naprogramovat hru v Mozilla Frameworku
</li><li>monost naprogramovat chování panáèka v JavaScriptu &ndash; uèení programování
</li></ul>

<p>Zejména poslední monost by mohla bıt pro Pedagogickou fakultu zajímavá.
Vytvoøilo by se rozhraní pro objekt horníka.
Kadé akci, které je horník schopen, by se pøiøadila metoda.
Poté by se uivateli umonilo zadat JavaScriptovı kód, ve kterém by volal tyto metody,
a tak by mohl naprogramovat chování horníka.
Vytvoøil by se tím podobnı nástroj pro uèení programování
jako známı Karel, navíc by bylo mono (ale ne nutno) pouít prostøedky OOP.

</p><p>Realizace by byla pomìrnì jednoduchá &ndash; uivatelem zadanı kód s funkcemi
by&nbsp;se vyhodnotil pomocí funkce <code>eval()</code>, která v pøípadì chybného kódu
vyhodí vıjimku, take by bylo mono uivateli sdìlit, kde je chyba,
a v pøípadì úspìšného vykonání bychom naètenou funkci zavolali.
Ta by provádìla akce, které by bylo vidìt na herním plánu i s vıslednım efektem.

</p></div>
			</div>
		</div>

		<!-- <div>
			<a name="k-b-2"></a>
			<h3>FlexiNET</h3>
			<div><!- -#include file="B-2.inc.html" - -></div>
		</div>
		<div>
			<a name="k-b-3"></a>
			<h3>Mozilla Calendar</h3>
			<div><!- -#include file="B-3.inc.html" - -></div>
		</div> -->
	</div>
	<!-- B. Praktická èást - KONEC -->
	

	
	<hr />
	
	<!-- Závìr -->
	<div id="zaver">
		<a name="k-z"></a>
		<h2>C. Závìr</h2>
		<div><!-- Závìr -->

<p>Úkolem této práce bylo dokázat, e i vıhradním pouitím JavaScriptu
bez podpory dalších technologií typu ActiveX, Java, Flash atd.
je mono vytvoøit smysluplné aplikace. Dùkazù bylo shromádìno tolik,
e o pouitelnosti JavaScriptu jako plnohodnotného programovacího jazyka
lze jen tìko pochybovat. Otázka tedy je, jak JavaScript obstojí v budoucnosti.

</p><p>S rostoucím vıkonem poèítaèù je mono pouívat skripty na takovıch místech,
kde by to bylo døíve stìí pøedstavitelné. Celkovı soudobı trend smìøuje
k oddìlení velkıch èástí aplikací a jejich realizaci v jazycích vyšší úrovnì,
a jazykùm niší úrovnì (napø. C++) jsou ponechávány jen èasovì nároèné procesy
a vrstva pro komunikaci s operaèním systémem.

</p><p>Podle dosavadního vıvoje JavaScriptu
a jeho postupného propojování s dalšími moderními technologiemi
(XML, HTML, CSS, SVG, Java, C#, COM, Flash) a jeho èím dál èastìjším nasazením
jako skriptovacího jazyka aplikací (Microsoft, Adobe, CAD & CAM programy,&nbsp;...)
je moné oèekávat,
e JavaScript se stane univerzálním programovacím jazykem, se kterım bude mono
naprogramovat prakticky cokoliv od jednoduchıch skriptù v HTML stránkách
pøes desktopové aplikace a po distribuované informaèní systémy.

</p><p>Zatím je však JavaScript stále vìtšinì programátorské komunity znám jako
chybovı nepøedvídatelnı jazyk vhodnı akorát pro skripty ve stránce.
Tento obraz má svoje dùvody v historii vıvoje, kdy se objevovaly chybné implementace
a chyby byly i v samotné specifikaci jazyka. Dnes jsou však tyto vady pøevánì odstranìny
a JavaScript mùe nastoupit cestu k vıše popsané pozici.

</p></div>
	</div><!-- Závìr - KONEC -->

	<!-- Zdroje -->
	<div id="zdroje">
		<a name="k-c"></a>
		<h2>D. Zdroje</h2>
		<div><div class="zdroj kniha">
<a name="zdroj_javascript"></a>
<div class="nazev">JavaScript - kompletní prùvodce, 2. aktualizované vydání</div>
<div class="nazev_originalni">(JavaScript: The Definitive Guide, Fourth Edition)</div>
<div class="autor">David Flanagan</div>
<div class="vydav">Coumputer Press 2002, O'Reilly</div>
<div class="isbn" >ISBN 80-7226-626-8</div>
</div>

<div class="zdroj kniha">
<a name="zdroj_tvorba"></a>
<div class="nazev">Skriptujeme operace na PC pomocí Microsoft Windows Script Host 2.0</div>
<div class="nazev_originalni">(Microsoft Windows Script Host 2.0 Developer's Guide)</div>
<div class="autor">Günter Born</div>
<div class="vydav">Computer Press 2001, Microsoft Corporation Inc. 2001</div>
<div class="isbn" >ISBN 80-7226-447-8</div>
</div>
												 
<div class="zdroj kniha">
<a name="zdroj_dhtml"></a>
<div class="nazev">Dynamické HTML</div>
<div class="nazev_originalni">(Inside Dynamic HTML)</div>
<div class="autor">Scott Isaacs</div>
<div class="vydav">Computer Press 1997, Microsoft Press 1997</div>
<div class="isbn" >ISBN 80-7226-083-9</div>
</div>
												 
<!-- Nepouzito -->
<!-- <div class="zdroj kniha">
<a name="zdroj_tvorba"></a>
<div class="nazev">JavaScript - tvorba dokonalıch WWW stránek - podrobnı prùvodce zaèínajícího uivatele</div>
<div class="nazev_originalni">(The ABCs of JavaScript)</div>
<div class="autor">Lee Purcell, Mary Jane Mara</div>
<div class="vydav">Grada Publishing 1998, SYBEX Inc. 1997</div>
<div class="isbn" >ISBN 80-7169-531-9</div>
</div> -->


<!-- Nepouzito -->
<!-- <a name="zdroj_php"></a>
<div class="zdroj kniha">
<div class="nazev">PHP - tvorba interaktivních internetovıch aplikací</div>
<div class="autor">Jiøí Kosek</div>
<div class="vydav">Grada Publishing 1999</div>
<div class="isbn" >ISBN 80-7169-373-1</div>
</div> -->

<a name="zdroj_ref_client"></a>
<div class="zdroj inet">
<div class="nazev">Client-Side JavaScript Reference v1.3</div>
<div class="autor">Netscape Communications Corporation 1999</div>
<div class="url"  ><a target="_blank" href="http://devedge.netscape.com/library/manuals/2000/javascript/1.3/reference/"
	>http://devedge.netscape.com/library/manuals/2000/javascript/1.3/reference/</a></div>
</div>

<a name="zdroj_ref_core"></a>
<div class="zdroj inet">
<div class="nazev">Core JavaScript Reference</div>
<div class="url"  ><a href="http://devedge.netscape.com/library/manuals/2000/javascript/1.5/reference/"
	>http://devedge.netscape.com/library/manuals/2000/javascript/1.5/reference/</a></div>
</div>

<div class="zdroj inet">
<a name="zdroj_xul"></a>
<div class="nazev">XPToolkit Project, XUL</div>
<div class="url"  ><a href="http://www.mozilla.org/xpfe/">http://www.mozilla.org/xpfe/</a></div>
</div>

<div class="zdroj inet">
<a name="zdroj_projektovani_is"></a>
<div class="nazev">Projektování informaèních systémù I</div>
<div class="url"  ><a href="http://zdenek2.euweb.cz/prois1.html">http://zdenek2.euweb.cz/prois1.html</a></div>
</div>

<div class="zdroj inet">
<a name="zdroj_interval_uml"></a>
<div class="nazev">Návrh aplikací v jazyce UML - Unified Modeling Language</div>
<div class="autor">René Stein, analytik a vıvojáø spoleènosti Digi-Trade</div>
<div class="url"  ><a href="http://interval.cz/clanek.asp?article=2783">http://interval.cz/clanek.asp?article=2783</a></div>
</div></div>
	</div><!-- Zdroje - KONEC -->
	


	<!-- Pøílohy -->
	<div id="prilohy">
		<a name="k-d"></a>
		<h2>E. Seznam pøíloh</h2>
		<div><!-- D. Seznam pøíloh  -->

<h6>Zdrojové kódy hry Miner JS</h6>
Seznam zdrojovıch souborù hry Miner JS.
Tuènì vyznaèené soubory jsou pøiloeny v tištìné verzi práce.

<table class="border_gray seznam" id="soubory">
<thead>
<tr><th>jméno souboru</th> <th>popis obsahu</th> <th>pojednávající kapitola</th></tr>
</thead>
<tbody>
          <tr><td><code class="file bold">index.html</code></td><td>hlavní dokument</td><td><a href="#k-b-1-3-rozvrzeni_dokumentu">Rozvrení dokumentu</a>
</td></tr><tr><td><code class="file bold">inc.bunky.js</code></td><td>tøídy pro práci s buòkami</td><td><a href="#k-b-1-4">Dekompozice</a>
</td></tr><tr><td><code class="file">inc.elements.js</code></td><td>knihovna pro simulaci objektu <code>document.all</code></td><td><a href="#k-b-1-4">Dekompozice</a>
</td></tr><tr><td><code class="file bold">inc.system.js</code></td><td>ošetøení událostí a nìkolik systémovıch funkcí</td><td>
</td></tr><tr><td><code class="file">inc.game.js</code></td><td>programovı kód hlavní tøídy <code>cGame</code></td><td><a href="#k-b-1-4">Dekompozice</a>
</td></tr><tr><td><code class="file bold">inc.panacek.js</code></td><td>tøídy pro práci s horníkem</td><td><a href="#k-b-1-4">Dekompozice</a>
</td></tr><tr><td><code class="file bold">inc.predmety.js</code></td><td>tøídy pro práci s pøedmìty a inventáøem</td><td><a href="#k-b-1-4">Dekompozice</a>
</td></tr><tr><td><code class="file">inc.konstanty.js</code></td><td>soubor s vìtšinou konstant</td><td><a href="#k-b-1-4">Dekompozice</a>
</td></tr><tr><td><code class="file">inc.saveload.js</code></td><td>tøídy pro ukládání a nahrávání stavu do cookies</td><td><a href="#k-b-1-4">Dekompozice</a>
</td></tr><tr><td><code class="file">fce.js</code></td><td>knihovna podpùrnıch funkcí</td><td>
</td></tr>
</tbody>
<tbody>
          <tr><td><code class="file bold">budova.banka.html</code></td><td>dokument pro budovu banky</td><td><a href="#k-b-1-2">Koncept hry</a>
</td></tr><tr><td><code class="file">budova.info.html</code></td><td>dokument pro budovu infocentra (nápovìda)</td><td><a href="#k-b-1-2">Koncept hry</a>
</td></tr><tr><td><code class="file">budova.nemocnice.html</code></td><td>dokument pro budovu nemocnice</td><td><a href="#k-b-1-2">Koncept hry</a>
</td></tr><tr><td><code class="file">budova.obchod.html</code></td><td>dokument pro budovu obchodu</td><td><a href="#k-b-1-2">Koncept hry</a>
</td></tr>
</tbody>
<tbody>
          <tr><td><code class="file">lang._.js</code></td><td>definice prom. pro implementaci lokalizace</td><td>
</td></tr><tr><td><code class="file">lang.cz.js</code></td><td>soubor s èeskımi lokalizovanımi øetìzci</td><td>
</td></tr><tr><td><code class="file">settings._.js</code></td><td>definice prom. pro impl. volitelnıch nastavení</td><td>
</td></tr><tr><td><code class="file">settings.default.js</code></td><td>soubor s vıchozím nastavením</td><td>
</td></tr><tr><td><code class="file bold">miner.css</code></td><td>CSS pravidla formátující dokument</td><td><a href="#k-b-1-3-rozvrzeni_dokumentu">Rozvrení dokumentu</a>
</td></tr><tr><td><code class="file">mineraly.css</code></td><td>doplòková CSS pravidla</td><td>
</td></tr>
</tbody>
</table>

<h6>Pøíklady</h6>
<div>Pøíklady k rùznım èástem popisu JavaScriptu v <a href="#k-a">teoretické èásti</a> této práce
se na pøiloeném CD nacházejí v adresáøi <code>diplomka/priklady/</code>.
</div>

<table class="border_gray seznam" id="priklady">
<tr><th>jméno souboru</th> <th>pojednávající kapitola</th> <th>pozn.</th></tr>
          <tr><td><a target="_blank" href="priklady/p-a-2-6-vicepole.html"><code class="file">p-a-2-6-vicepole.html</code></a></td> <td><a href="#k-a-2-6-vicepole">Vestavìné objekty a metody - Array</a></td><td>vyvolá vıjimku
</td></tr><tr><td><a target="_blank" href="priklady/p-a-3-1-window_global.html"><code class="file">p-a-3-1-window_global.html</code></a></td> <td><a href="#k-a-3-1-window_global">Objekt <code>window</code> jako globální objekt</a></td><td><code>window.Array</code>
</td></tr><tr><td><a target="_blank" href="priklady/p-a-3-4-listy_stylu.html"><code class="file">p-a-3-4-listy_stylu.html</code></a></td> <td><a href="#k-a-3-4-listy_stylu">Provázanost JavaScriptu s CSS - Listy stylù</a></td><td>funguje jen ve FF
</td></tr><tr><td><a target="_blank" href="priklady/p-a-3-5-cookies.html"><code class="file">p-a-3-5-cookies.html</code></a></td> <td><a href="#k-a-3-5">Provázanost JavaScriptu s Cookies</a></td><td>
</td></tr><tr><td><a target="_blank" href="priklady/p-a-1-4-rozhrani.html"><code class="file">p-a-1-4-rozhrani.html</code></a></td> <td><a href="k-a-1-4-rozhrani">Monosti JavaScriptu pøi dekompozici - Rozhraní (interface)</a></td><td>funguje jen ve FF
</td></tr><tr><td><a target="_blank" href="priklady/p-a-1-5-procesy.js"><code class="file">p-a-1-5-procesy.js</code></a></td> <td><a href="#k-a-1-5">Dekompozice a kooperativní programování</a></td><td>Skript pro WSH
<!-- </td></tr><tr><td><a target="_blank" href="priklady/"><code class="file"></code></a></td> <td><a href="#"></a></td><td> -->
</td></tr>
</table>


<h6>Test-case soubory</h6>
<p>Pokud v prùbìhu vıvoje narazím na nìjakı zádrhel, obvykle neoèekávané chování prohlíeèe,
mám ve zvyku vytvoøit soubor s pøedponou <code>sm_</code> a v nìm danou vlastnost otestovat.
Takovım souborùm se øíká test-case (testovací pøípad).
Nìkdy je vısledek zajímavı a soubor si ponechám pro pøípadné opìtovné testování.
Soubory takto vzniklé bìhem vıvoje hry Miner JS jsou na CD v adresáøi <code>miner/real/testy/</code>.
</p></div>
	</div><!-- #prilohy - KONEC -->
	
	
	</div><!-- #text - KONEC -->
	
</div><!-- #content - KONEC -->


<!-- <div style="border: 3px solid green; width: 100%; height: 20px; position: relative;"> -->
<div id="splashscreen_obalka" style="xvisibility: hidden;">
	<!-- <div class="UNIcenter"> -->
	<div id="splashscreen">
		<div class="vnitrek">
			<h4>Tvorba klientskıch aplikací v JavaScriptu</h4>
			<p><em id="splashscreen_zprava">Probíhá aplikace typografickıch pravidel, prosím èekejte...</em></p>
		</div>
	</div>
	<!-- </div> -->
</div>
<!-- </div> -->

</body>
</html>